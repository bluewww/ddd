// $Id$
// Agent interface on a callback basis

// Copyright (C) 1995 Technische Universitaet Braunschweig, Germany.
// Written by Andreas Zeller <zeller@ips.cs.tu-bs.de>.
// 
// This file is part of the DDD Library.
// 
// The DDD Library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Library General Public
// License as published by the Free Software Foundation; either
// version 2 of the License, or (at your option) any later version.
// 
// The DDD Library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the GNU Library General Public License for more details.
// 
// You should have received a copy of the GNU Library General Public
// License along with the DDD Library -- see the file COPYING.LIB.
// If not, write to the Free Software Foundation, Inc.,
// 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
// 
// DDD is the data display debugger.
// For details, see the DDD World-Wide-Web page, 
// `http://www.cs.tu-bs.de/softech/ddd/',
// or send a mail to the DDD developers <ddd@ips.cs.tu-bs.de>.

char LiterateAgent_rcsid[] = 
    "$Id$";

#ifdef __GNUG__
#pragma implementation
#endif

#include "config.h"
#include <iostream.h>
#include <sys/types.h>
#include <unistd.h>
#include <errno.h>
#include <stdio.h>		// On Linux, includes _G_config.h

#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#endif

#if defined(HAVE_FCNTL) && !defined(HAVE_FCNTL_DECL) && !defined(fcntl)
extern "C" int fcntl(int fd, int command, ...);
#endif

#include "bool.h"
#include "LiterateA.h"
#include "SignalB.h"
#include "ChunkQueue.h"

// This package reads data in non-blocking mode, reading only data
// that is currently present.  Unfortunately, this is not a good idea
// for ttys, since if the process is run in the background, it will
// set non-blocking mode for its controlling tty.  Since this mode
// change affects all processes reading from this tty, they will
// detect an EOF on input and (most likely) exit.

// Consequently, we provide a special flag, called BLOCK_TTY_INPUT.
// If BLOCK_TTY_INPUT is set (non-zero), we use blocking mode for TTYs
// and read only one line at a time.  This works fine unless the
// process runs in raw or cbreak mode.  If BLOCK_TTY_INPUT is not set,
// we have no special treatment for TTYs.

// According to Ray Dassen <jdassen@wi.LeidenUniv.nl>, Linux with GNU
// libc 6 wants BLOCK_TTY_INPUT to be unset.
#if !defined(BLOCK_TTY_INPUT) \
    && _LINUX_C_LIB_VERSION_MAJOR > 5
#define BLOCK_TTY_INPUT 0	// libc 6 and later
#endif

// According to Terence Spielman <terence@globeset.com>, this is also
// true for Linux with GNU libc 5.4.35.  Anders Wegge Jakobsen
// <wegge@wegge.dk> reports the same for GNU libc 5.4.38.  On the
// other hand, Linux with GNU libc 5.4.33 and earlier, however, needs
// BLOCK_TTY_INPUT being set.  Hence, we set BLOCK_TTY_INPUT only for
// GNU libc 5.4.33 and earlier.
#if !defined(BLOCK_TTY_INPUT) \
    && _LINUX_C_LIB_VERSION_MAJOR == 5 \
    && _LINUX_C_LIB_VERSION_MINOR > 4
#define BLOCK_TTY_INPUT 0	// libc 5.5 and later
#endif
#if !defined(BLOCK_TTY_INPUT) \
    && _LINUX_C_LIB_VERSION_MAJOR == 5 \
    && _LINUX_C_LIB_VERSION_MINOR == 4 \
    && _LINUX_C_LIB_VERSION_SUBMINOR > 33
#define BLOCK_TTY_INPUT 0	// libc 5.4.34 and later
#endif
#if !defined(BLOCK_TTY_INPUT) \
    && _LINUX_C_LIB_VERSION_MAJOR <= 5
#define BLOCK_TTY_INPUT 1	// libc 5.4.33 and earlier
#endif

// For all other systems, the default is BLOCK_TTY_INPUT set.  (I
// don't know whether this is the `best' setting, but I have no reason
// to change a default that has been around successfully for so long...)
#if !defined(BLOCK_TTY_INPUT)
#define BLOCK_TTY_INPUT 1
#endif

DEFINE_TYPE_INFO_1(LiterateAgent, AsyncAgent)

// Check if fp is a tty and wants blocking input
inline bool blocking_tty(FILE *fp)
{
    return BLOCK_TTY_INPUT && isatty(fileno(fp));
}

// I/O functions

// Input data handling
int LiterateAgent::readInput(char*& data)
{
    data = "";
    if (inputfp() == 0 || !activeIO)
	return -1;

    return _readInput(data);
}

// Error data handling
int LiterateAgent::readError(char*& data)
{
    data = "";
    if (errorfp() == 0 || !activeIO)
	return -1;

    return _readError(data);
}

// write a whole string
int LiterateAgent::write(const char *data, int length)
{
    if (outputfp() == 0 || !activeIO)
	return -1;

    int failures = 0;

    while (length > 0)
    {
	errno = 0;
	int nitems = ::write(fileno(outputfp()), data, length);

	if (nitems == 0)
	{
	    if (errno)
	    {
		if (++failures <= 3)
		{
		    ostrstream os;
		    os << "write failed (attempt #" 
		       << failures << ", still trying)";
		    string s(os);
		    raiseIOMsg(s);
		    sleep(1);
		    continue;
		}
		else
		{
		    raiseIOMsg("write failed");
		    return -1;
		}
	    }
	}

	dispatch(Output, (char *)data, nitems);

	length -= nitems;
	data += nitems;
    }

    if (failures)
	raiseMsg("write ok");

    return 0;
}

// flush output buffers
int LiterateAgent::flush()
{
    // Not needed, since we use immediate write()
    return 0;
}


// read from fp without delay
int LiterateAgent::_readNonBlocking(char *buffer, int nelems, FILE *fp)
{
    // Avoid being stopped when file is non-blocking
    SignalBlocker sb;

    // Make file non-blocking
    int flags = fcntl(fileno(fp), F_GETFL, 0);
    if (flags == -1)
	_raiseIOWarning("cannot get file descriptor status flags");
    if (fcntl(fileno(fp), F_SETFL, flags | O_NONBLOCK) == -1)
	_raiseIOWarning("cannot set file to non-blocking mode");

    // Read stuff
    int nitems = fread(buffer, sizeof(char), nelems, fp);

    // Reset file state
    if (fcntl(fileno(fp), F_SETFL, flags) == -1)
	_raiseIOWarning("cannot restore file mode");

    return nitems;
}


// read from fp
int LiterateAgent::_read(char*& data, FILE *fp)
{
    static ChunkQueue queue;

    queue.discard();
    char buffer[BUFSIZ + 1];
    
    if (blocking_tty(fp))
    {
	// Non-blocking ttys are nasty, so we read only the 
	// single line available here and now.
	char *s = fgets(buffer, BUFSIZ, fp);

	if (s != 0)
	    queue.append(buffer, strlen(buffer));
    }
    else
    {
	// Otherwise, read and accumulate whatever's there - up to
	// BUFSIZ characters
	int length = -1;
	while (queue.length() < BUFSIZ
	       && (length = _readNonBlocking(buffer, BUFSIZ, fp)) > 0)
	    queue.append(buffer, length);

	if (length < 0)
	    raiseIOMsg("read from agent failed");
    }

    data = queue.data();
    return queue.length();
}

int LiterateAgent::_readInput(char*& data)
{
    return _read(data, inputfp());
}

int LiterateAgent::_readError(char*& data)
{
    return _read(data, errorfp());
}



// Dispatchers

// dispatch data to <type> handler 
void LiterateAgent::dispatch(int type, char *data, int length)
{
    char c = data[length];
    if (c != '\0')
	data[length] = '\0';

    DataLength dl(data, length);

    // call global handlers
    callHandlers(type, &dl);

    if (c != '\0')
	data[length] = c;
}
    

// Handlers

// Data handlers

void LiterateAgent::outputReady(AsyncAgent *c)
{
    ptr_cast(LiterateAgent, c)->callHandlers(Ready);
}

void LiterateAgent::inputReady(AsyncAgent *c)
{
    bool expectEOF = false;
    char data[1024];
    char *datap = data;
    LiterateAgent *leeLA = ptr_cast(LiterateAgent, c);
    if (leeLA)
    {
	int length = leeLA->readInput(datap);
	if (length > 0)
	    leeLA->dispatch(Input, datap, length);
	else if (!expectEOF && length == 0 
		 && leeLA->inputfp() != 0 && feof(leeLA->inputfp()))
	    leeLA->inputEOF();
    }
}

void LiterateAgent::errorReady(AsyncAgent *c)
{
    bool expectEOF = false;
    char data[1024];
    char *datap = data;
    LiterateAgent *leeLA = ptr_cast(LiterateAgent, c);
    if (leeLA)
    {
	int length = leeLA->readError(datap);
	if (length > 0)
	    leeLA->dispatch(Error, datap, length);
	else if (!expectEOF && length == 0 
		 && leeLA->errorfp() != 0 && feof(leeLA->errorfp()))
	    leeLA->errorEOF();
    }
}

// Input Data is available: read all and call Input handlers of current job
void LiterateAgent::readAndDispatchInput(bool expectEOF)
{
    char *data;

    int length = readInput(data);
    if (length > 0)
	dispatch(Input, data, length);
    else if (!expectEOF && length == 0 && inputfp() != 0 && feof(inputfp()))
	inputEOF();
}

// Error Data is available: read all and call Error handlers of current job
void LiterateAgent::readAndDispatchError(bool expectEOF)
{
    char *data;

    int length = readError(data);
    if (length > 0)
	dispatch(Error, data, length);
    else if (!expectEOF && length == 0 && errorfp() != 0 && feof(errorfp()))
	errorEOF();
}


// (Re)set I/O handlers
void LiterateAgent::handlerChange()
{
    if (activeIO)
	_activateIO();
}

// Activate Handlers
void LiterateAgent::_activateIO()
{
    // We do select this event only if a handler is present
    // Otherwise, outputReady() may be called all the time
    setHandler(OutputReady, hasHandler(Ready) ? outputReady : 0);
    setHandler(InputReady,  inputReady);
    setHandler(ErrorReady,  errorReady);
}

// Deactivate Handlers
void LiterateAgent::_deactivateIO()
{
    setHandler(OutputReady, 0);
    setHandler(InputReady,  0);
    setHandler(ErrorReady,  0);
}


// Starter
void LiterateAgent::start()
{
    AsyncAgent::start();
    
    // dispatch input data that may already be there
    if (inputfp() != NULL && !blocking_tty(inputfp()))
	readAndDispatchInput();

    if (errorfp() != NULL && !blocking_tty(errorfp()))
	readAndDispatchError();
}

// Terminator
void LiterateAgent::abort()
{
    // dispatch remaining input data (if there is some remaining)
    activateIO();
    readAndDispatchInput(true);
    readAndDispatchError(true);

    // now, clean up
    deactivateIO();
    AsyncAgent::abort();
}
