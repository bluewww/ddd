// $Id$ -*- C++ -*-
// DDD command queue

// Copyright (C) 1996-1997 Technische Universitaet Braunschweig, Germany.
// Written by Andreas Zeller <zeller@ips.cs.tu-bs.de>.
// 
// This file is part of the DDD Library.
// 
// The DDD Library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Library General Public
// License as published by the Free Software Foundation; either
// version 2 of the License, or (at your option) any later version.
// 
// The DDD Library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the GNU Library General Public License for more details.
// 
// You should have received a copy of the GNU Library General Public
// License along with the DDD Library -- see the file COPYING.LIB.
// If not, write to the Free Software Foundation, Inc.,
// 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
// 
// DDD is the data display debugger.
// For details, see the DDD World-Wide-Web page, 
// `http://www.cs.tu-bs.de/softech/ddd/',
// or send a mail to the DDD developers at `ddd@ips.cs.tu-bs.de'.

char commandQueue_rcsid[] = 
    "$Id$";

#ifdef __GNUG__
#pragma implementation
#pragma implementation "Queue.h"
#endif

#include "commandQ.h"
#include "comm-manag.h"
#include "status.h"
#include "exectty.h"
#include "cmdtty.h"
#include "findParent.h"
#include "history.h"
#include "ddd.h"
#include "cook.h"
#include "Queue.h"
#include "windows.h"
#include "GDBAgent.h"

#include <ctype.h>
#include <string.h>
#include <Xm/Xm.h>
#include <Xm/Text.h>
#include <X11/StringDefs.h>

#define LOG_QUEUE 0

// Origin of last command
static Widget gdb_last_origin;

//-----------------------------------------------------------------------------
// GDB command management
//-----------------------------------------------------------------------------

static void ClearOriginCB(Widget w, XtPointer, XtPointer)
{
    if (gdb_last_origin == w)
	gdb_last_origin = 0;
}

void _gdb_command(string command, Widget origin, OQCProc callback, 
		  void *data, bool verbose, bool check)
{
    if (gdb->isReadyWithPrompt())
    {
	set_status("");

	if (command.length() == 1 && iscntrl(command[0]))
	    promptPosition = messagePosition = XmTextGetLastPosition(gdb_w);

	handle_running_commands(command, origin);

	if (command.length() == 0)
	{
	    _gdb_out(gdb->prompt());
	    return;
	}
    }

    gdb_keyboard_command = private_gdb_input;

    if (gdb_last_origin != 0)
    {
	XtRemoveCallback(gdb_last_origin, XtNdestroyCallback, 
			 ClearOriginCB, 0);
    }

    gdb_last_origin = find_shell(gdb_keyboard_command ? gdb_w : origin);

    if (gdb_last_origin != 0)
    {
	XtAddCallback(gdb_last_origin, XtNdestroyCallback, 
		      ClearOriginCB, 0);
    }

    user_cmdSUC(command, origin, callback, data, verbose, check);
    messagePosition = XmTextGetLastPosition(gdb_w);
}


//-----------------------------------------------------------------------------
// Command queue
//-----------------------------------------------------------------------------

// Command queue
struct Command
{
    string command;		// Command text
    Widget origin;		// Origin
    OQCProc callback;		// Associated callback
    void *data;			// Data for callback
    bool verbose;		// Flag: verbose output?
    bool check;			// Flag: append GDB commands?

private:
    static void clear_origin(Widget w, XtPointer client_data, 
			     XtPointer call_data);

    void add_destroy_callback()
    {
	if (origin != 0)
	    XtAddCallback(origin, XtNdestroyCallback, clear_origin, 
			  (XtPointer)this);
    }

    void remove_destroy_callback()
    {
	if (origin != 0)
	    XtRemoveCallback(origin, XtNdestroyCallback, clear_origin,
			     (XtPointer)this);
    }

public:
    Command(const string& cmd, Widget w, OQCProc cb, void *d = 0, 
	    bool v = false, bool c = false)
	: command(cmd), origin(w), callback(cb), data(d), verbose(v), check(c)
    {
	add_destroy_callback();
    }
    Command(const string& cmd, Widget w)
	: command(cmd), origin(w), callback(0), data(0), 
	  verbose(true), check(true)
    {
	add_destroy_callback();
    }
    Command(const Command& c)
	: command(c.command), origin(c.origin), callback(c.callback), 
	  data(c.data), verbose(c.verbose), check(c.check)
    {
	add_destroy_callback();
    }
    ~Command()
    {
	remove_destroy_callback();
    }
    Command& operator = (const Command& c)
    {
	if (this != &c)
	{
	    remove_destroy_callback();

	    command  = c.command;
	    origin   = c.origin;
	    callback = c.callback;
	    data     = c.data;
	    verbose  = c.verbose;
	    check    = c.check;

	    add_destroy_callback();
	}
	return *this;
    }
    bool operator == (const Command& c)
    {
	return this == &c || 
	    command == c.command 
	    && origin == c.origin 
	    && callback == c.callback 
	    && data == c.data
	    && verbose == c.verbose
	    && check == c.check;
    }
};

void Command::clear_origin(Widget w, XtPointer client_data, XtPointer)
{
    (void) w;			// Use it

    // The widget is being destroyed.  Remove all references.
    Command *command = (Command *)client_data;
    assert(w == command->origin);
    command->origin = 0;
}

typedef Queue<Command> CommandQueue;
typedef QueueIter<Command> CommandQueueIter;

static CommandQueue commandQueue;

#if LOG_QUEUE
static ostream& operator<<(ostream& os, const CommandQueue& queue)
{
    os << "[";
    bool first = true;
    for (CommandQueueIter i = queue; i.ok(); i = i.next())
    {
	if (first)
	    first = false;
	else
	    os << ", ";

	os << quote(i().command);
    }
    return os << "]";
}
#endif

void clearCommandQueue()
{
    while (!commandQueue.isEmpty())
    {
	const Command& cmd = commandQueue.first();
	if (cmd.callback != 0)
	{
	    // We're deleting a command with associated callback Call
	    // callback with NO_GDB_ANSWER such that it can clean up
	    // the associated data.
	    cmd.callback(NO_GDB_ANSWER, cmd.data);
	}
	commandQueue -= cmd;
    }

#if LOG_QUEUE
    clog << "Command queue: " << commandQueue << "\n";
#endif
}

bool emptyCommandQueue()
{
    return commandQueue.isEmpty();
}

void gdb_command(const string& cmd, Widget origin, 
		 OQCProc callback, void *data, bool verbose, bool check)
{
    if (cmd.length() == 1 && iscntrl(cmd[0]) || cmd == "no" || cmd == "yes")
    {
	_gdb_command(cmd, origin, callback, data, verbose, check);

	if (cmd != "yes")
	{
	    // Probably some canceling command - clear remaining commands
	    clearCommandQueue();
	}
	return;
    }

    if (gdb->isReadyWithPrompt() && emptyCommandQueue())
    {
	if (callback == 0)
	    add_to_history(cmd);

	_gdb_command(cmd, origin, callback, data, verbose, check);
    }
    else
    {
	Command c(cmd, origin, callback, data, verbose, check);

	if (callback != 0)
	{
	    // Enqueue before first command without callback.  This
	    // ensures that user commands are placed at the end.
	    CommandQueueIter pos = commandQueue;
	    bool have_pos = false;

	    for (CommandQueueIter i = commandQueue; i.ok(); i = i.next())
	    {
		if (i().callback == 0)
		    break;

		pos = i;
		have_pos = true;
	    }

	    if (have_pos)
		commandQueue.enqueue_after(c, pos);
	    else
		commandQueue.enqueue_at_start(c);
	}
	else
	{
	    // Enqueue command at end
	    commandQueue.enqueue_at_end(c);
	}

#if LOG_QUEUE
	clog << "Command queue: " << commandQueue << "\n";
#endif
    }
}

void processCommandQueue(XtPointer, XtIntervalId *)
{
    if (!gdb->isReadyWithPrompt())
    {
	// Try again later...
	XtAppAddTimeOut(XtWidgetToApplicationContext(gdb_w), 
			200, processCommandQueue, XtPointer(0));
	return;
    }

    if (!emptyCommandQueue())
    {
	const Command& c = commandQueue.first();
	Command cmd(c);
	commandQueue.dequeue(c);

	add_to_history(cmd.command);
	_gdb_command(cmd.command, cmd.origin, cmd.callback, 
		     cmd.data, cmd.verbose, cmd.check);

	gdb_keyboard_command = false;

#if LOG_QUEUE
	clog << "Command queue: " << commandQueue << "\n";
#endif
    }
}

static bool ddd_is_idle = false;
static Boolean ddd_idle(XtPointer)
{
    ddd_is_idle = emptyCommandQueue() && gdb->isReadyWithPrompt();
    return ddd_is_idle;		// If idle, remove from the list of work procs
}

// Wait for command queue to drain
void syncCommandQueue()
{
    ddd_is_idle = false;
    XtAppAddWorkProc(XtWidgetToApplicationContext(command_shell),
		     ddd_idle, 0);

    while (!ddd_is_idle)
    {
	processCommandQueue();
	XtAppProcessEvent(XtWidgetToApplicationContext(command_shell),
			  XtIMTimer | XtIMAlternateInput);
    }
}

// Shell finder
Widget find_shell(Widget w)
{
    if (w == 0)
	w = gdb_last_origin;
    if (w == 0)
	return command_shell;

    Widget parent = findTopLevelShellParent(w);
    if (parent == 0)
	return command_shell;

    XWindowAttributes xwa;
    XGetWindowAttributes(XtDisplay(parent), XtWindow(parent), &xwa);
    if (xwa.map_state != IsViewable)
	return command_shell;

    return parent;
}



// Batch management

static void auto_cmd_done(const string& answer, void *)
{
    if (answer != "")
    {
	// Dumb hack to ensure we don't issue the output after the prompt
	gdb_out("\r");
	messagePosition = XmTextGetLastPosition(gdb_w);
	gdb_out(answer);
	prompt();
    }
}

static bool get_line(string& source, string& cmd)
{
    int index = source.index('\n');
    if (index >= 0)
    {
	cmd = source.before(index);
	source = source.after(index);
    }
    else
    {
	cmd = source;
	source = "";
    }
    return cmd.length() > 0;
}

static void ProcessBatch(XtPointer client_data, XtIntervalId *)
{
    string source = (char *)client_data;
    delete[] (char *)client_data;

    // Debugger issued DDD command(s).  Enqueue them.
    string cmd;
    while (get_line(source, cmd))
	gdb_command(cmd, gdb_w, auto_cmd_done, 0, false, true);
}

// Process auto commands
void gdb_batch(const string& cmd)
{
    char *data = strcpy(new char[cmd.length() + 1], cmd.chars());
    XtAppAddTimeOut(XtWidgetToApplicationContext(gdb_w), 
		    0, ProcessBatch, XtPointer(data));
}
