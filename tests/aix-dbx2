DDD 1998-07-09 (powerpc-ibm-aix4.1.5.0), Copyright (C) 1998 TU Braunschweig.
Compiled with GCC egcs-2.90.29 980515 (egcs-1.0.3 release), libstdc++ 2.8.0
Requires X11R5, Xt11R5, Motif 1.2.3 (OSF/Motif Version 1.2.3)
Includes DDD core, manual, app-defaults, XPM 3.4.10, Athena Panner
Built 1998-07-10 by Jens Krinke  <jkrinke@watson.ibm.com>.
$  ddd --dbx writer
+  /bin/sh -c 'exec dbx '\''writer'\'''
#  Hello, world!
#  Starting DBX...
#  Raising core file size limit from 1073741312 to 2147483647 bytes...
#  Raising core file size limit from 1073741312 to 2147483647 bytes...done.
#  Running DBX (pid 33900, tty /dev/pts/15)...
#  DBX: EOF detected
<- "Type \'help\' for help.\n"
<- "reading symbolic information ..."
<- "\n"
<- "(dbx) "
-> "sh stty -echo -onlcr\n"
<- "(dbx) "
-> "set $page = 1\n"
<- "(dbx) "
-> "frame\n"
<- "frame\n"
<- "^ unrecognized command\n"
<- "(dbx) "
-> "func\n"
<- "main\n"
<- "(dbx) "
-> "dbxenv run_io\n"
<- "dbxenv run_io\n"
<- "^ unrecognized command\n"
<- "(dbx) "
-> "print -r 4711\n"
<- "\"r\" is not defined\n"
<- "(dbx) "
-> "where -h\n"
<- "__start() at 0x100001c8\n"
<- "where -h\n"
<- "      ^ syntax error\n"
<- "(dbx) "
-> "display\n"
<- "display\n"
<- "^ unrecognized command\n"
<- "(dbx) "
-> "clear\n"
<- "clear\n"
<- "     ^ syntax error\n"
<- "(dbx) "
-> "help handler\n"
<- "handler is not a known help topic or command\n"
<- "(dbx) "
-> "pwd\n"
<- "pwd\n"
<- "^ unrecognized command\n"
<- "(dbx) "
-> "help setenv\n"
<- "setenv is not a known help topic or command\n"
<- "(dbx) "
-> "help edit\n"
<- "edit\n"
<- "edit <filename>\n"
<- "edit <procedure>\n"
<- "\tInvoke an editor on <filename> or the current source file\n"
<- "\tif none is specified. If a procedure or function name\n"
<- "\tis specified the editor is invoked on the file that\n"
<- "\tcontains it. The default editor is the vi editor.\n"
<- "\tThe default can be overridden by setting the environment\n"
<- "\tvariable EDITOR to the name of the desired editor.\n"
<- "(dbx) "
-> "help make\n"
<- "make is not a known help topic or command\n"
<- "(dbx) "
-> "help regs\n"
<- "regs is not a known help topic or command\n"
<- "(dbx) "
-> "print \"DDD\"\n"
<- "DDD \n"
<- "(dbx) "
-> "help when\n"
<- "no help available for when\n"
<- "(dbx) "
-> "delete 4711 4711\n"
<- "unknown event 4711\n"
<- "(dbx) "
-> "help run\n"
<- "run [<arguments>] [< <filename>] [> <filename>] \n"
<- "                    [>> <filename>] [>! <filename>] \n"
<- "                    [2> <filename>] [2>> <filename>] \n"
<- "                    [>& <filename>] [>>& <filename>] \n"
<- "rerun [<arguments>] [< <filename>] [> <filename>] \n"
<- "                    [>> <filename>] [>! <filename>] \n"
<- "                    [2> <filename>] [2>> <filename>] \n"
<- "                    [>& <filename>] [>>& <filename>] \n"
<- "\tStart executing the object file, passing arguments as\n"
<- "\tcommand line arguments; < or > can be used to redirect\n"
<- "\tinput or output in a shell-like manner. When \"rerun\"\n"
<- "\tis used without any arguments the previous argument list\n"
<- "\tis passed to the program; otherwise it is identical to run.\n"
<- "(dbx) "
-> "help givenfile\n"
<- "givenfile is not a known help topic or command\n"
<- "(dbx) "
-> "help cont\n"
<- "cont\n"
<- "cont <signal-number>\n"
<- "cont <signal-name>\n"
<- "\tContinue execution from where it stopped. If a signal\n"
<- "\tis specified, the process continues as though it\n"
<- "\treceived the signal. Otherwise, the process is continued\n"
<- "\tas though it had not been stopped.\n"
<- "(dbx) "
-> "sh pwd\n"
<- "/u/jkrinke/src/dakota/builder\n"
<- "(dbx) "
-> "file\n"
<- "Writer.C\n"
<- "(dbx) "
-> "list\n"
<- "    1   #include <iostream.h>\n"
<- "    2   #include <stdlib.h>\n"
<- "    3   \n"
<- "    4   #include \"Dakota.H\"  \n"
<- "    5   #include \"Ohio.H\"\n"
<- "    6   #include \"FrontEnd.H\"\n"
<- "    7   #include \"MontanaFrontEnd.H\"\n"
<- "    8   #include \"WriterArg.H\"\n"
<- "    9   #include \"OhioFrontEnd.H\"\r\n"
<- "   10   \n"
<- "(dbx) "
-> "status\n"
<- "(dbx) "
#  Reading file "/u/jkrinke/src/dakota/builder/Writer.C"...
#  Reading file "/u/jkrinke/src/dakota/builder/Writer.C"...done.
#  File "/u/jkrinke/src/dakota/builder/Writer.C" 66 lines, 1604 characters
-> "debug \n"
<- "debug \n"
<- "      ^ syntax error\n"
<- "(dbx) "
-> "# reset\n"
<- "# reset\n"
<- "^ unrecognized command\n"
<- "(dbx) "
-> "file\n"
<- "Writer.C\n"
<- "(dbx) "
-> "list\n"
<- "   11   WriterArg arg;   // input arguments\n"
<- "   12   \n"
<- "   13   int main(int argc, char *argv[]) \n"
<- "   14   {\n"
<- "   15     // check which interface the user has used (menu or command line)\n"
<- "   16     if (argc == 2) \n"
<- "   17        arg.readMenuOptions();\n"
<- "   18     else\n"
<- "   19        arg.processCommandLineOptions(argc, argv);\n"
<- "   20   \n"
<- "(dbx) "
-> "status\n"
<- "(dbx) "
-> "debug \n"
<- "debug \n"
<- "      ^ syntax error\n"
<- "(dbx) "
-> "help detach\n"
<- "detach\n"
<- "detach <sig_num>\n"
<- "detach <sig_name>\n"
<- "\tContinues execution from where it stopped without debugger\n"
<- "\tcontrol. If a signal is specified, the process continues\n"
<- "\tas though it received a signal. Otherwise, the debugger will\n"
<- "\texit, but the debugged process shall continue.\n"
<- "(dbx) "
-> "help run\n"
<- "run [<arguments>] [< <filename>] [> <filename>] \n"
<- "                    [>> <filename>] [>! <filename>] \n"
<- "                    [2> <filename>] [2>> <filename>] \n"
<- "                    [>& <filename>] [>>& <filename>] \n"
<- "rerun [<arguments>] [< <filename>] [> <filename>] \n"
<- "                    [>> <filename>] [>! <filename>] \n"
<- "                    [2> <filename>] [2>> <filename>] \n"
<- "                    [>& <filename>] [>>& <filename>] \n"
<- "\tStart executing the object file, passing arguments as\n"
<- "\tcommand line arguments; < or > can be used to redirect\n"
<- "\tinput or output in a shell-like manner. When \"rerun\"\n"
<- "\tis used without any arguments the previous argument list\n"
<- "\tis passed to the program; otherwise it is identical to run.\n"
<- "(dbx) "
-> "help step\n"
<- "step\n"
<- "step <count>\n"
<- "\tExecute one source line.\n"
<- "\tIf a count is supplied, execute the next count source lines.\n"
<- "\tThe difference between this and \"next\" is that if the line\n"
<- "\tcontains a call to a procedure or function the \"step\"\n"
<- "\tcommand will enter that procedure or function, while the \n"
<- "\t\"next\" command will not.\n"
<- "\tSee also: set_variables $stepignore\n"
<- "(dbx) "
#  Starting DBX...done.
#  Welcome to DDD 1998-07-09!
-> "help stepi\n"
<- "stepi\n"
<- "stepi <count>\n"
<- "\tExecute a single instruction.\n"
<- "\tIf a count is supplied, execute the next count instructions.\n"
<- "(dbx) "
-> "help next\n"
<- "next\n"
<- "next <count>\n"
<- "\tExecute up to the next source line. If a count is supplied\n"
<- "\texecute the next count source lines. The difference between\n"
<- "\tthis and \"step\" is that if the line contains a call\n"
<- "\tto a procedure or function the \"step\" command will\n"
<- "\tstop at the beginning of that block, while the \"next\"\n"
<- "\tcommand will not.\n"
<- "(dbx) "
-> "help nexti\n"
<- "nexti\n"
<- "nexti <count>\n"
<- "\tSingle step as in \"next\", but do a single instruction\n"
<- "\trather than source line. If a count is supplied\n"
<- "\texecute the nexti count instructions.\n"
<- "(dbx) "
-> "help until\n"
<- "until is not a known help topic or command\n"
<- "(dbx) "
-> "help cont\n"
<- "cont\n"
<- "cont <signal-number>\n"
<- "cont <signal-name>\n"
<- "\tContinue execution from where it stopped. If a signal\n"
<- "\tis specified, the process continues as though it\n"
<- "\treceived the signal. Otherwise, the process is continued\n"
<- "\tas though it had not been stopped.\n"
<- "(dbx) "
-> "help signal\n"
<- "signal is not a known help topic or command\n"
<- "(dbx) "
-> "help kill\n"
<- "kill is not a known help topic or command\n"
<- "(dbx) "
-> "help up\n"
<- "up\n"
<- "up <count>\n"
<- "down\n"
<- "down <count>\n"
<- "\tMove the current function, which is used for resolving\n"
<- "\tnames, up or down the stack <count> levels. The default\n"
<- "\t<count> is one.\n"
<- "(dbx) "
-> "help down\n"
<- "up\n"
<- "up <count>\n"
<- "down\n"
<- "down <count>\n"
<- "\tMove the current function, which is used for resolving\n"
<- "\tnames, up or down the stack <count> levels. The default\n"
<- "\t<count> is one.\n"
<- "(dbx) "
-> "print \"iostream.h =\", iostream.h\n"
<- "\"iostream\" is not defined\n"
<- "(dbx) "
-> "file Writer.C\n"
<- "(dbx) "
-> "status\n"
<- "(dbx) "
-> "stop at 35\n"
<- "[1] stop at \"Writer.C\":35\n"
<- "(dbx) "
-> "status\n"
<- "[1] stop at \"Writer.C\":35\n"
<- "(dbx) "
-> "rerun ../test/working/callgraph.icc\n"
<- "\n"
<- "\n"
<- "\n"
<- "\n"
<- "\n"
<- "        WRITER  Menu\n"
<- "\n"
<- " -Displace Trace Information [y/n]?  (default=n) "
-> "\n"
<- " -Generate NARC files [y/n]?  (default=n) "
-> "\n"
<- " -Write the Ohio File twice [y/n]?  (default=n) "
-> "\n"
<- "\n"
<- "Using Montana to construct PCG and CFGs for \'../test/working/callgraph.icc\'.\n"
<- "   Incoporation Time: 0.44 seconds.\n"
<- "File incorporated by Montana....\n"
<- "[1] stopped in main at line 35 in file \"Writer.C\"\n"
<- "   35     if (arg.narc())\n"
<- "(dbx) "
-> "file\n"
<- "Writer.C\n"
<- "(dbx) "
-> "status\n"
<- "[1] stop at \"Writer.C\":35\n"
<- "(dbx) "
-> "print \"n =\", n\n"
<- "\""
<- "n"
<- "\" is not defined"
<- "\n"
<- "(dbx) "
-> "print *root._pcg\n"
<- "\""
<- "_pcg"
<- "\" is not defined in "
<- "OM_PCG::root() const"
<- "\n"
<- "(dbx) "
-> "status\n"
<- "[1] stop at \"Writer.C\":35\n"
<- "(dbx) "
-> "func\n"
<- "main\n"
<- "(dbx) "
-> "print \"*pcg._root =\", *pcg._root\n"
<- "*pcg._root =     OM_PCGComponent:(_PCG = \n"
<- "        OM_PCGDownCasters:()\n"
<- "    (_root = 0x201ba678, _functionList = (_first = 0x201ba678, _last = 0x201c82c8), _frontEnd = (_fileName = \"../test/working/callgraph.icc\", _factory = \n"
<- "                OM_FactoryDownCasters:()\n"
<- "            (), \n"
<- " _symboltable = (_table = (\n"
<- "(_first = 0x201cc4b8, _last = 0x201cc4b8)\n"
<- "(_first = 0x201c85a8, _last = 0x201c85a8)\n"
<- "(_first = (nil), _last = (nil))\n"
<- "(_first = (nil), _last = (nil))\n"
<- "), _iteratorIndex = 0, _numEntries = 2), _buildTime = 0.02), _directoryName = \"../test/working/callgraph.results\", _baseFileName = \"../test/working/callgraph\", _forward = (_first = 0x201c8368, _last = 0x201c82a8), _backward = (_first = 0x201c81f8, _last = 0x201bb138), _forwardNext = (nil), _backwardNext = (nil), _topSortListSize = 3, _isRecursive = 0, _historyStack = (_first = (nil), _last = (nil)), _num_functions = 4, _num_structors = 0, _num_callnodes = 3, _num_calledges = 3, _num_ifs = 0, _num_dos = 0, _num_whiles = 0, _num_fors = 0, _num_binaryassigns = 0, _num_unaryassigns = 0, _num_exprs = 0, _num_endifs = 0, _num_entrys = 4, _num_exits = 4, _num_headers = 0, _num_breaks = 0, _num_breakexits = 0, _num_continues = 0, _num_switches = 0, _num_endswitches = 0, _num_cases = 0, _num_defaults = 0, _num_labels = 0, _num_gotos = 0, _num_nodes = 11, _num_edges = 7, _topNumCounter = 4))\n"
<- "    CS_Link<OM_Function>:(_next = 0x201c8188)\n"
<- "    OM_FunctionDownCasters:()\n"
<- "(_isRecursive = 0, _name = \"main()\", _shortName = \"main\", _functionKind = OM_Function::RegularFunction, _returnsPtr = 0, _returnsArray = 0, _returnsReference = 0, _number = 1, _topNumber = 1, _visited = 0, _controlFlowGraph = 0x201c8388, _formalList = (_first = (nil), _last = (nil)), _localList = (_first = (nil), _last = (nil)), _callNodeList = (_first = 0x201cc468, _last = 0x201cc468), _callerEdgeList = (_first = (nil), _last = (nil))) \n"
<- "(dbx) "
#  Creating display...
#  Creating display...done.
#  Display 1: *pcg._root (enabled, scope main)
#  Display 1: *pcg._root (enabled, scope main)
-> "quit\n"
#  DBX: EOF detected
#  Running DBX (pid 33900, tty /dev/pts/15)...Exit 0.
#  Saving history in "/u/jkrinke/.ddd/history"...
#  Saving history in "/u/jkrinke/.ddd/history"...done.
#  Thanks for using DDD 1998-07-09!
