GNU DDD 3.1.90 (alphaev56-dec-osf4.0d)
Copyright (C) 1999 Technische Universitaet Braunschweig, Germany.
Copyright (C) 1999 Universitaet Passau, Germany.
Compiled with cxx
Requires X11R6, Xt11R6, Motif 1.2.4 (OSF/Motif Version 1.2.4)
Includes DDD core, Readline 2.2, Manual, App defaults, XPM 3.4.11, Athena Panner
Built 1999-11-05 by MIDOL-MONNET P <st01511@152.13.110.140>.
$  ./ddd --ladebug ctest
+  /bin/sh -c 'exec ladebug '\''ctest'\'''
#  Hello, world!
#  Starting Ladebug...
#  Running Ladebug (pid 17678, tty /dev/ttyP0)...
#  Current language: c/c++
#  Creating "/home/st01511/.ddd/"...
#  Creating "/home/st01511/.ddd/"...done.
#  Creating "/home/st01511/.ddd/sessions/"...
#  Creating "/home/st01511/.ddd/sessions/"...done.
<- "Welcome to the Ladebug Debugger Version 4.0-43\n"
<- "------------------ \n"
<- "object file name: ctest \n"
<- "Reading symbolic information ...done\n"
<- "(ladebug) "
-> "sh stty -echo -onlcr\n"
<- "\033[J "
<- "\033[C\033[D\033[J"
<- " "
<- "\033[J "
<- "\033[D\033[D\033[D\033[J "
<- " "
<- "\033[C\033[D\033[J"
<- " "
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[C\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\n"
<- "(ladebug) "
-> "set $page = 1\n"
<- "\033[J "
<- "\033[D\033[J "
<- "\033[C\033[D\033[J"
<- " "
<- "\033[C\033[D"
<- "\033[J "
<- "\033[C\033[D\033[J"
<- " "
<- "\033[C\033[D\033[J"
<- " "
<- "\033[C\033[D\033[J"
<- " "
<- "\033[C\033[D\033[J"
<- " "
<- "(ladebug) "
-> "frame\n"
<- "frame\n"
<- "\033[J "
<- "\033[D\033[J "
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[D\033[D\033[D\033[J "
<- "\033[C\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C\n"
<- "frame\n"
<- "    ^"
<- "\n"
<- "Unable to parse input as legal command or C expression.\n"
<- "(ladebug) "
-> "func\n"
<- "\033[J "
<- "\033[D\033[J "
<- "\033[C\033[D\033[J"
<- " "
<- " "
<- "\n"
<- "int main(int, char**) in ./ctest.c line No. 252:\n"
<- "    252     int i = 42;\n"
<- "(ladebug) "
-> "dbxenv run_io\n"
<- "\033[J "
<- "\033[D\033[J "
<- "\033[C\033[D"
<- "\033[J "
<- "\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\n"
<- "dbxenv run_io\n"
<- "     ^"
<- "\n"
<- "Unable to parse input as legal command or C expression.\n"
<- "(ladebug) "
-> "print -r 4711\n"
<- "\033[J "
<- "\033[D\033[J "
<- "\033[C\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\n"
<- "print -r"
<- " 4711\n"
<- "            ^\n"
<- "Unable to parse input as legal command or C expression.\n"
<- "(ladebug) "
-> "where -h\n"
<- "\033[J "
<- "\033[D\033[J "
<- "\033[C\033[D"
<- "\033[J "
<- "\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\n"
<- "The \"where\" command has failed because there is no running program.\n"
<- "(ladebug) "
-> "display\n"
<- "\033[J "
<- "\033[C\033[D\033[J"
<- " "
<- "\033[D\033[J "
<- "\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\n"
<- "display\n"
<- "      ^"
<- "\n"
<- "Unable to parse input as legal command or C expression.\n"
<- "(ladebug) "
-> "clear\n"
<- "\033[J "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[J "
<- "\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C\n"
<- "clear\n"
<- "    ^\n"
<- "Unable to parse input as legal command or C expression.\n"
<- "(ladebug) "
-> "help handler\n"
<- "\033[J "
<- "\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\n"
<- "Information about \"handler\" isn\'t available\n"
<- "\n"
<- "\n"
<- "\n"
<- "Welcome to the Ladebug debugger help system. \n"
<- " \n"
<- "To find out about:  \n"
<- " \n"
<- "        - starting up a program in Ladebug \n"
<- "                enter \'help start\' \n"
<- " \n"
<- "        - stopping at a specific place in your program \n"
<- "                enter \'help breakpoint\' \n"
<- " \n"
<- "        - making the program execute \n"
<- "                enter \'help execution\' \n"
<- " \n"
<- "        - determining the type or value of a program variable \n"
<- "                enter \'help variable\' \n"
<- " \n"
<- "        - reading or writing a memory location \n"
<- "                enter \'help memory\' \n"
<- " \n"
<- "        - reading or writing a register \n"
<- "                enter \'help register\' \n"
<- " \n"
<- "        - showing the current call stack \n"
<- "                enter \'help stack\' \n"
<- " \n"
<- "        - displaying the source text of your program \n"
<- "                enter \'help listing\' \n"
<- " \n"
<- "        - listing all of the ladebug commands \n"
<- "                enter \'help ladebug\' or \'help command\' \n"
<- " \n"
<- "To find out about all of the Ladebug commands, use \n"
<- "\'help ladebug\' or \'help command\'.  To find out about  \n"
<- "a specific command, use help, followed by the command  \n"
<- "verb, such as \'help quit\'.\n"
<- "(ladebug) "
-> "pwd\n"
<- "\033[J "
<- "\033[C\033[D"
<- "\033[J "
<- "\033[D\033[J "
<- "\n"
<- "pwd\n"
<- "  ^\n"
<- "Unable to parse input as legal command or C expression.\n"
<- "(ladebug) "
-> "help setenv\n"
<- "\033[J "
<- "\033[C\033[D"
<- "\033[J "
<- "\033[D\033[J "
<- "\033[D\033[D\033[D\033[J "
<- "\033[C\033[D\033[J"
<- " "
<- "\033[D\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\n"
<- "        setenv [<env_variable> [<value>]] \n"
<- "\n"
<- "Sets the value of the specified environment variable. If no variable \n"
<- "is specified, the command displays the values of all environment \n"
<- "variables. If a variable is specified but no value is specified, then \n"
<- "the variable is set to NULL. \n"
<- "\n"
<- "This command is not for the current debuggee\'s environment, but for \n"
<- "the environment of any debuggees subsequently created with fork(2) or \n"
<- "with subsequent \'run\' or \'rerun\' commands. \n"
<- "\n"
<- "\'export\' and \'setenv\' are synonyms. \n"
<- "\n"
<- "See the Ladebug Debugger Manual for more information on commands that \n"
<- "manipulate the environment of subsequent debuggees. \n"
<- "(ladebug) "
-> "help edit\n"
<- "\033[J"
<- " "
<- "\033[D\033[J "
<- "\033[C\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\n"
<- "Information about \"edit\" isn\'t available\n"
<- "\n"
<- "\n"
<- "\n"
<- "Welcome to the Ladebug debugger help system. \n"
<- " \n"
<- "To find out about:  \n"
<- " \n"
<- "        - starting up a program in Ladebug \n"
<- "                enter \'help start\' \n"
<- " \n"
<- "        - stopping at a specific place in your program \n"
<- "                enter \'help breakpoint\' \n"
<- " \n"
<- "        - making the program execute \n"
<- "                enter \'help execution\' \n"
<- " \n"
<- "        - determining the type or value of a program variable \n"
<- "                enter \'help variable\' \n"
<- " \n"
<- "        - reading or writing a memory location \n"
<- "                enter \'help memory\' \n"
<- " \n"
<- "        - reading or writing a register \n"
<- "                enter \'help register\' \n"
<- " \n"
<- "        - showing the current call stack \n"
<- "                enter \'help stack\' \n"
<- " \n"
<- "        - displaying the source text of your program \n"
<- "                enter \'help listing\' \n"
<- " \n"
<- "        - listing all of the ladebug commands \n"
<- "                enter \'help ladebug\' or \'help command\' \n"
<- " \n"
<- "To find out about all of the Ladebug commands, use \n"
<- "\'help ladebug\' or \'help command\'.  To find out about  \n"
<- "a specific command, use help, followed by the command  \n"
<- "verb, such as \'help quit\'.\n"
<- "(ladebug) "
-> "help make\n"
<- "\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[D\033[D\033[D\033[J"
<- " "
<- "\033[D\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C\n"
<- "Information about \"make\" isn\'t available\n"
<- "\n"
<- "\n"
<- "\n"
<- "Welcome to the Ladebug debugger help system. \n"
<- " \n"
<- "To find out about:  \n"
<- " \n"
<- "        - starting up a program in Ladebug \n"
<- "                enter \'help start\' \n"
<- " \n"
<- "        - stopping at a specific place in your program \n"
<- "                enter \'help breakpoint\' \n"
<- " \n"
<- "        - making the program execute \n"
<- "                enter \'help execution\' \n"
<- " \n"
<- "        - determining the type or value of a program variable \n"
<- "                enter \'help variable\' \n"
<- " \n"
<- "        - reading or writing a memory location \n"
<- "                enter \'help memory\' \n"
<- " \n"
<- "        - reading or writing a register \n"
<- "                enter \'help register\' \n"
<- " \n"
<- "        - showing the current call stack \n"
<- "                enter \'help stack\' \n"
<- " \n"
<- "        - displaying the source text of your program \n"
<- "                enter \'help listing\' \n"
<- " \n"
<- "        - listing all of the ladebug commands \n"
<- "                enter \'help ladebug\' or \'help command\' \n"
<- " \n"
<- "To find out about all of the Ladebug commands, use \n"
<- "\'help ladebug\' or \'help command\'.  To find out about  \n"
<- "a specific command, use help, followed by the command  \n"
<- "verb, such as \'help quit\'.\n"
<- "(ladebug) "
-> "help regs\n"
<- "\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C\033[D\033[J"
<- " "
<- " "
<- "\033[D\033[J "
<- "\n"
<- "Information about \"regs\" isn\'t available\n"
<- "\n"
<- "\n"
<- "\n"
<- "Welcome to the Ladebug debugger help system. \n"
<- " \n"
<- "To find out about:  \n"
<- " \n"
<- "        - starting up a program in Ladebug \n"
<- "                enter \'help start\' \n"
<- " \n"
<- "        - stopping at a specific place in your program \n"
<- "                enter \'help breakpoint\' \n"
<- " \n"
<- "        - making the program execute \n"
<- "                enter \'help execution\' \n"
<- " \n"
<- "        - determining the type or value of a program variable \n"
<- "                enter \'help variable\' \n"
<- " \n"
<- "        - reading or writing a memory location \n"
<- "                enter \'help memory\' \n"
<- " \n"
<- "        - reading or writing a register \n"
<- "                enter \'help register\' \n"
<- " \n"
<- "        - showing the current call stack \n"
<- "                enter \'help stack\' \n"
<- " \n"
<- "        - displaying the source text of your program \n"
<- "                enter \'help listing\' \n"
<- " \n"
<- "        - listing all of the ladebug commands \n"
<- "                enter \'help ladebug\' or \'help command\' \n"
<- " \n"
<- "To find out about all of the Ladebug commands, use \n"
<- "\'help ladebug\' or \'help command\'.  To find out about  \n"
<- "a specific command, use help, followed by the command  \n"
<- "verb, such as \'help quit\'.\n"
<- "(ladebug) "
-> "print \"DDD\"\n"
<- "\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[D\033[J "
<- "\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C\033[D\033[J"
<- " "
<- " "
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C"
<- "\n"
<- "DDD\n"
<- "(ladebug) "
-> "help when\n"
<- "\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[D\033[J "
<- "\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C\n"
<- "\n"
<- "\twhen {<command>[;...]} \n"
<- "\twhen if <expression> {<command>[;...]} \n"
<- "\twhen at <line_number> [if <expression>] {<command>[;...]} \n"
<- "\twhen in function [if <expression>] {<command>[;...]} \n"
<- "\twhen [thread <thread_identifier_list>] \n"
<- "\t [at <line_number>] [if <expression>] {<command>[;...]} \n"
<- "\twhen [thread <thread_identifier_list>] \n"
<- "\t [in <function>] [if <expression>] {<command>[;...]} \n"
<- "\n"
<- "Use the \'when\' command to execute the specified command. \n"
<- "(The \'when\' command does not suspend program execution.) \n"
<- "The debugger command must be enclosed in braces. Separate multiple \n"
<- "commands with semicolons. \n"
<- "\n"
<- "To execute a command when an expression evaluates true, use the second form. \n"
<- "To execute commands when a line or function is encountered, use the third \n"
<- "or fourth form. \n"
<- "\n"
<- "If you specify an expression, the command is executed only if the \n"
<- "expression evaluates true when the line or function is encountered. \n"
<- "\n"
<- "Use the \'when thread\' command to set tracepoints in specific threads. \n"
<- "If you list one or more thread identifiers, the debugger sets a tracepoint \n"
<- "only in those threads you specify.  If you omit the thread identifier \n"
<- "specification, the ebugger sets a tracepoint in all the threads of the \n"
<- "application. \n"
<- "(ladebug) "
-> "delete 4711 4711\n"
<- "\033[J"
<- " "
<- "\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C\n"
<- "dele"
<- "te 4711 4711\n"
<- "               ^"
<- "\n"
<- "Unable to parse input as legal command or C expression.\n"
<- "(ladebug) "
-> "help run\n"
<- "\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[C\033[D"
<- "\033[J "
<- "\033[D\033[D\033[D\033[J "
<- "\033[C\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C\n"
<- "\n"
<- "        run [<program arguments>] [<io redirection>] \n"
<- "        rerun [<program arguments>] [<io redirection>] \n"
<- "\n"
<- "Use the \'run\' and \'rerun\' commands to start program execution. \n"
<- "Enter program flags, options, and input and output redirections \n"
<- "as arguments. If the \'rerun\' command is specified without \n"
<- "arguments, the arguments entered with the previous \'run\' \n"
<- "command are used.  If the last modification time and/or \n"
<- "size of the binary file or any of the shared objects used \n"
<- "by the binary file has changed since the last \'run\' command \n"
<- "was issued,  Ladebug automatically rereads the symbol \n"
<- "table information.  If this happens, the old breakpoint \n"
<- "settings may no longer be valid after the new symbol table \n"
<- "information is read. \n"
<- "(ladebug) "
-> "help givenfile\n"
<- "\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[D\033[D\033[D\033[J "
<- "\033[C\033[D\033[J "
<- "\033[C\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\n"
<- "Information about \"givenfile\" isn\'t available\n"
<- "\n"
<- "\n"
<- "\n"
<- "Welcome to the Ladebug debugger help system. \n"
<- " \n"
<- "To find out about:  \n"
<- " \n"
<- "        - starting up a program in Ladebug \n"
<- "                enter \'help start\' \n"
<- " \n"
<- "        - stopping at a specific place in your program \n"
<- "                enter \'help breakpoint\' \n"
<- " \n"
<- "        - making the program execute \n"
<- "                enter \'help execution\' \n"
<- " \n"
<- "        - determining the type or value of a program variable \n"
<- "                enter \'help variable\' \n"
<- " \n"
<- "        - reading or writing a memory location \n"
<- "                enter \'help memory\' \n"
<- " \n"
<- "        - reading or writing a register \n"
<- "                enter \'help register\' \n"
<- " \n"
<- "        - showing the current call stack \n"
<- "                enter \'help stack\' \n"
<- " \n"
<- "        - displaying the source text of your program \n"
<- "                enter \'help listing\' \n"
<- " \n"
<- "        - listing all of the ladebug commands \n"
<- "                enter \'help ladebug\' or \'help command\' \n"
<- " \n"
<- "To find out about all of the Ladebug commands, use \n"
<- "\'help ladebug\' or \'help command\'.  To find out about  \n"
<- "a specific command, use help, followed by the command  \n"
<- "verb, such as \'help quit\'.\n"
<- "(ladebug) "
-> "help cont\n"
<- "\033[J"
<- " "
<- "\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[D\033[J "
<- "\n"
<- "        cont [<signal>] [to <line_number>] \n"
<- "        cont [in <function>] \n"
<- "\n"
<- "Use the \'cont\' command without a parameter value to resume program \n"
<- "execution until a breakpoint, a signal, an error, or the end of \n"
<- "the program is encountered.  Specify a signal parameter value to send \n"
<- "an operating system signal to the program continuing execution. \n"
<- "Specify a to line_number parameter value to halt program execution \n"
<- "when that line number is reached. \n"
<- "\n"
<- "When you use the \'cont\' commmand, Ladebug resumes execution of the \n"
<- "entire process. \n"
<- "\n"
<- "The signal parameter value can be either a signal number or a \n"
<- "string name (for example, SIGSEGV).  The default is 0, which \n"
<- "allows the program to continue execution without specifying a \n"
<- "signal.  If you specify a signal parameter value, the program \n"
<- "continues execution with that signal. \n"
<- "\n"
<- "The \'to line_number\' parameter value is used to resume execution and \n"
<- "then halt when the specified source line is reached. \n"
<- "\n"
<- "The form of the optional line_number argument must be one of the \n"
<- "following: \n"
<- "\t- line_number, a positive numeric, which indicates the \n"
<- "           line number of the current source file where execution \n"
<- "           is to be halted \n"
<- "        - \"filename\":line_number, which explicitly identifies both \n"
<- " \t  the source file and the line number where execution \n"
<- "          is to be halted. \n"
<- "\n"
<- "If the optional function name is provided, execution will be halted \n"
<- "when that function is reached.  This form of the \'cont\' command does \n"
<- "not support signals.  If the function name is overloaded, the user is \n"
<- "prompted with a choice of overloaded function names or \'none of the above\'. \n"
<- "Depending on user choice, program execution continues until the \n"
<- "specified function is reached or warns the user that no breakpoint is set.\n"
<- "If the \'none of the above\' option is specified, program execution returns \n"
<- "to the \'ladebug\' prompt.\n"
<- "(ladebug) "
-> "help examine\n"
<- "\033[J"
<- " "
<- "\033[C"
<- "\033[D"
<- "\033[J "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[J"
<- " "
<- "\033[D"
<- "\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\n"
<- "Information about \"examine\" isn\'t available\n"
<- "\n"
<- "\n"
<- "\n"
<- "Welcome to the Ladebug debugger help system. \n"
<- " \n"
<- "To find out about:  \n"
<- " \n"
<- "        - starting up a program in Ladebug \n"
<- "                enter \'help start\' \n"
<- " \n"
<- "        - stopping at a specific place in your program \n"
<- "                enter \'help breakpoint\' \n"
<- " \n"
<- "        - making the program execute \n"
<- "                enter \'help execution\' \n"
<- " \n"
<- "        - determining the type or value of a program variable \n"
<- "                enter \'help variable\' \n"
<- " \n"
<- "        - reading or writing a memory location \n"
<- "                enter \'help memory\' \n"
<- " \n"
<- "        - reading or writing a register \n"
<- "                enter \'help register\' \n"
<- " \n"
<- "        - showing the current call stack \n"
<- "                enter \'help stack\' \n"
<- " \n"
<- "        - displaying the source text of your program \n"
<- "                enter \'help listing\' \n"
<- " \n"
<- "        - listing all of the ladebug commands \n"
<- "                enter \'help ladebug\' or \'help command\' \n"
<- " \n"
<- "To find out about all of the Ladebug commands, use \n"
<- "\'help ladebug\' or \'help command\'.  To find out about  \n"
<- "a specific command, use help, followed by the command  \n"
<- "verb, such as \'help quit\'.\n"
<- "(ladebug) "
-> "help rerun\n"
<- "\033[J"
<- " "
<- "\033[D"
<- "\033[J "
<- "\033[C"
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[J"
<- " "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\n"
<- "\n"
<- "        run [<program arguments>] [<io redirection>] \n"
<- "        rerun [<program arguments>] [<io redirection>] \n"
<- "\n"
<- "Use the \'run\' and \'rerun\' commands to start program execution. \n"
<- "Enter program flags, options, and input and output redirections \n"
<- "as arguments. If the \'rerun\' command is specified without \n"
<- "arguments, the arguments entered with the previous \'run\' \n"
<- "command are used.  If the last modification time and/or \n"
<- "size of the binary file or any of the shared objects used \n"
<- "by the binary file has changed since the last \'run\' command \n"
<- "was issued,  Ladebug automatically rereads the symbol \n"
<- "table information.  If this happens, the old breakpoint \n"
<- "settings may no longer be valid after the new symbol table \n"
<- "information is read. \n"
<- "(ladebug) "
-> "language\n"
<- "\033[J"
<- " "
<- "\033[D"
<- "\033[J "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[J"
<- " "
<- "\033[D"
<- "\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\n"
<- "lan"
<- "guage\n"
<- "       ^"
<- "\n"
<- "Unable to parse input as legal command or C expression.\n"
<- "(ladebug) "
-> "sh pwd\n"
<- "\033[J"
<- " "
<- "\033[D"
<- "\033[J "
<- "\033[D"
<- "\033[J "
<- "\033[D\033[D\033[D\033[J"
<- " "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\n"
<- "/local/home/si/st01511/ddd-3.1.90/ddd\n"
<- "(ladebug) "
-> "file\n"
<- "file\n"
<- "\033[J"
<- " "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\n"
<- "./ctest.c\n"
<- "(ladebug) "
-> "list\n"
<- "list\n"
<- "\033[J"
<- " "
<- "\033[D"
<- "\033[J "
<- "\033[C"
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[J"
<- " "
<- "\n"
<- "    253     tree_test();\n"
<- "    254     i++;\n"
<- "    255     list_test(i);\n"
<- "    256     i++;\n"
<- "    257     array_test();\n"
<- "    258     i++;\n"
<- "    259     type_test();\n"
<- "    260     --i;\n"
<- "    261     in_out_test();\n"
<- "    262     return 0;\n"
<- "    263 }\n"
<- "(ladebug) "
-> "status\n"
<- "\033[J"
<- " "
<- "\033[D"
<- "\033[J "
<- "\033[C"
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[J"
<- " "
<- "\033[D"
<- "\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\n"
<- "(ladebug) "
#  Reading file "/local/home/si/st01511/ddd-3.1.90/ddd/file"...
#  Reading file "/local/home/si/st01511/ddd-3.1.90/ddd/file"...No such file or directory.
-> "setenv EDITOR \"echo\"\n"
<- "\033[J "
<- "\033[D\033[J "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[J"
<- " "
<- "\033[D"
<- "\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J"
<- " "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C\033[D\033[D\033[D\033[D\033[D\033[J"
<- " "
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C\033[D\033[D\033[D\033[D\033[D\033[J"
<- " "
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\n"
<- "(ladebug) "
-> "edit file\n"
<- "edit file\n"
<- "\033[J"
<- " "
<- "\033[D"
<- "\033[J "
<- "\033[D"
<- "\033[J "
<- "\033[D\033[D\033[D\033[J"
<- " "
<- "\033[D"
<- "\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C\n"
<- "ed"
<- "it file\n"
<- "   ^"
<- "\n"
<- "Unable to parse input as legal command or C expression.\n"
<- "(ladebug) "
-> "setenv EDITOR \"xem\"\n"
<- "\033[J"
<- " "
<- "\033[D\033[J"
<- " "
<- "\033[D"
<- "\033[J "
<- "\033[D\033[D\033[D\033[J"
<- " "
<- "\033[D"
<- "\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D"
<- "\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C\n"
<- "(ladebug) "
#  Reading file "file" from Ladebug...
-> "list 1,1000000\n"
<- "\033[J "
<- "\033[C"
<- "\033[D\033[J"
<- " "
<- "\033[D"
<- "\033[J "
<- "\033[D\033[D\033[D\033[J"
<- " "
<- "\033[D"
<- "\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[C"
<- "\n"
<- "      1 /* $Id$ */\n"
<- "      2 /* C Test program */\n"
<- "      3 \n"
<- "      4 /*\n"
<- "      5  * Copyright (C) 1995 Technische Universitaet Braunschweig, Germany.\n"
<- "      6  * Written by Andreas Zeller <zeller@gnu.org>.\n"
<- "      7  * \n"
<- "      8  * This file is part of DDD.\n"
<- "      9  * \n"
<- "     10  * DDD is free software; you can redistribute it and/or\n"
<- "     11  * modify it under the terms of the GNU General Public\n"
<- "     12  * License as published by the Free Software Foundation; either\n"
<- "     13  * version 3 of the License, or (at your option) any later version.\n"
<- "     14  * \n"
<- "     15  * DDD is distributed in the hope that it will be useful,\n"
<- "     16  * but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
<- "     17  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n"
<- "     18  * See the GNU General Public License for more details.\n"
<- "     19  * \n"
<- "     20  * You should have received a copy of the GNU General Public\n"
<- "     21  * License along with DDD -- see the file COPYING.\n"
<- "     22  * If not, see <http://www.gnu.org/licenses/>.\n"
<- "     24  * \n"
<- "     25  * DDD is the data display debugger.\n"
<- "     26  * For details, see the DDD World-Wide-Web page, \n"
<- "     27  * `http://www.gnu.org/software/ddd/\',\n"
<- "     28  * or send a mail to the DDD developers <ddd@gnu.org>.\n"
<- "     29  */\n"
<- "     30 \n"
<- "     31 /* --------------------------------------------------------------------------\n"
<- "     32  *  This program defines some data structures and values that may be\n"
<- "     33  *  examined using DDD.\n"
<- "     34  * --------------------------------------------------------------------------\n"
<- "     35  */\n"
<- "     36 \n"
<- "     37 char ctest_rcsid[] =\n"
<- "     38     \"$Id$\";\n"
<- "     39 \n"
<- "     40 #include <stdio.h>\n"
<- "     41 #include <stdlib.h>\n"
<- "     42 #include <string.h>\n"
<- "     43 \n"
<- "     44 typedef enum _DayOfWeek {Sun, Mon, Tue, Wed, Thu, Fri, Sat} DayOfWeek;\n"
<- "     45 \n"
<- "     46 int a_global = 42;\t/* Place watchpoints on this one */\n"
<- "     47 \n"
<- "     48 typedef struct Date {\n"
<- "     49     DayOfWeek day_of_week;\n"
<- "     50     int day;\n"
<- "     51     int month;\n"
<- "     52     int year;\n"
<- "     53 } Date;\n"
<- "     54 \n"
<- "     55 void set_date(d, day_of_week, day, month, year)\n"
<- "     56     Date *d;\n"
<- "     57     DayOfWeek day_of_week;\n"
<- "     58     int day, month, year;\n"
<- "     59 {\n"
<- "     60     d->day_of_week = day_of_week;\n"
<- "     61     d->day         = day;\n"
<- "     62     d->month       = month;\n"
<- "     63     d->year        = year;\n"
<- "     64 }\n"
<- "     65 \n"
<- "     66 Date *new_date(day_of_week, day, month, year)\n"
<- "     67     DayOfWeek day_of_week;\n"
<- "     68     int day, month, year;\n"
<- "     69 {\n"
<- "     70     Date *date = (Date *)malloc(sizeof(Date));\n"
<- "     71     set_date(date, day_of_week, day, month, year);\n"
<- "     72 \n"
<- "     73     return date;\n"
<- "     74 }\n"
<- "     75 \n"
<- "     76 void free_date(date)\n"
<- "     77     Date *date;\n"
<- "     78 {\n"
<- "     79     free(date);\n"
<- "     80 }\n"
<- "     81 \n"
<- "     82 /*--------------------------------------------------------------------------*/\n"
<- "     83 typedef struct _Holiday {\n"
<- "     84     Date date;\n"
<- "     85     char *name;\n"
<- "     86 } Holiday;\n"
<- "     87 \n"
<- "     88 void set_holiday(d, day_of_week, day, month, year, name)\n"
<- "     89     Holiday *d;\n"
<- "     90     DayOfWeek day_of_week;\n"
<- "     91     int day, month, year;\n"
<- "     92     char *name;\n"
<- "     93 {\n"
<- "     94     set_date(&d->date, day_of_week, day, month, year);\n"
<- "     95     d->name = name;\n"
<- "     96     a_global = 1;\n"
<- "     97 }\n"
<- "     98 \n"
<- "     99 /*--------------------------------------------------------------------------*/\n"
<- "    100 typedef struct _Tree {\n"
<- "    101     int   value;\n"
<- "    102     char *name;\n"
<- "    103 \n"
<- "    104     Date date;\n"
<- "    105     struct _Tree *left;\n"
<- "    106     struct _Tree *right;\n"
<- "    107 } Tree;\n"
<- "    108 \n"
<- "    109 Tree *new_tree(value, name)\n"
<- "    110     int value;\n"
<- "    111     char *name;\n"
<- "    112 {\n"
<- "    113     Tree *tree = (Tree *)malloc(sizeof(Tree));\n"
<- "    114     tree->value = value;\n"
<- "    115     tree->name  = name;\n"
<- "    116     tree->left  = NULL;\n"
<- "    117     tree->right = NULL;\n"
<- "    118 \n"
<- "    119     return tree;\n"
<- "    120 }\n"
<- "    121 \n"
<- "    122 void free_tree(tree)\n"
<- "    123     Tree *tree;\n"
<- "    124 {\n"
<- "    125     if (tree->left)\n"
<- "    126 \tfree_tree(tree->left);\n"
<- "    127     if (tree->right)\n"
<- "    128 \tfree_tree(tree->right);\n"
<- "    129 \n"
<- "    130     free(tree);\n"
<- "    131 }\n"
<- "    132 \n"
<- "    133 /*--------------------------------------------------------------------------*/\n"
<- "    134 typedef struct _List {\n"
<- "    135     int value;\n"
<- "    136 \n"
<- "    137     struct _List *self;\n"
<- "    138     struct _List *next;\n"
<- "    139 } List;\n"
<- "    140 \n"
<- "    141 List *new_list(value)\n"
<- "    142     int value;\n"
<- "    143 {\n"
<- "    144     List *list = (List *)malloc(sizeof(List));\n"
<- "    145     list->value = value;\n"
<- "    146     list->self  = list;\n"
<- "    147     list->next  = list;\n"
<- "    148 \n"
<- "    149     return list;\n"
<- "    150 }\n"
<- "    151 \n"
<- "    152 /*--------------------------------------------------------------------------*/\n"
<- "    153 void tree_test ()\n"
<- "    154 {\n"
<- "    155     Tree *tree = NULL;\n"
<- "    156     tree =              new_tree (7, \"Ada\");      /* Byron Lovelace */\n"
<- "    157     tree->left =        new_tree (1, \"Grace\");    /* Murray Hopper  */\n"
<- "    158     tree->left->left =  new_tree (5, \"Judy\");     /* Clapp          */\n"
<- "    159     tree->left->right = new_tree (6, \"Kathleen\"); /* McNulty        */\n"
<- "    160     tree->right =       new_tree (9, \"Mildred\");  /* Koss           */\n"
<- "    161 \n"
<- "    162     set_date(&tree->date, Tue, 29, 11, 1994);\n"
<- "    163     set_date(&tree->date, Wed, 30, 11, 1994);\n"
<- "    164 \n"
<- "    165     free_tree(tree);\n"
<- "    166 }\n"
<- "    167 \n"
<- "    168 /*--------------------------------------------------------------------------*/\n"
<- "    169 void list_test(start)\n"
<- "    170     int start;\n"
<- "    171 {\n"
<- "    172     List *list = 0;\n"
<- "    173 \n"
<- "    174     list                         = new_list(a_global + start++);\n"
<- "    175     list->next                   = new_list(a_global + start++);\n"
<- "    176     list->next->next             = new_list(a_global + start++);\n"
<- "    177     list->next->next->next       = list;\n"
<- "    178 \n"
<- "    179     free(list->next->next);\n"
<- "    180     free(list->next);\n"
<- "    181     free(list);\n"
<- "    182 }\n"
<- "    183 \n"
<- "    184 /*--------------------------------------------------------------------------*/\n"
<- "    185 void array_test ()\n"
<- "    186 {\n"
<- "    187     int i;\n"
<- "    188     static DayOfWeek days_of_week[7] = {Sun, Mon, Tue, Wed, Thu, Fri, Sat};\n"
<- "    189 \n"
<- "    190     static char* twodim [2][3] = {{ \"Pioneering\", \"women\", \"in\"},\n"
<- "    191 \t\t\t\t  { \"computer\", \"science\", \"!\"}};\n"
<- "    192 \n"
<- "    193     Date dates[4];\n"
<- "    194     Date* date_ptrs[4];\n"
<- "    195     date_ptrs[0] = new_date (Thu, 1, 9, 1994);\n"
<- "    196     date_ptrs[1] = new_date (Tue, 10, 5, 1994);\n"
<- "    197     date_ptrs[2] = new_date (Fri, 15, 7, 1994);\n"
<- "    198     date_ptrs[3] = new_date (Sat, 24, 12, 1994);\n"
<- "    199 \n"
<- "    200     for (i = 0; i < 4; i++)\n"
<- "    201     {\n"
<- "    202 \tdates[i] = *date_ptrs[i];\n"
<- "    203 \tfree_date(date_ptrs[i]);\n"
<- "    204     }\n"
<- "    205 }\n"
<- "    206 \n"
<- "    207 /*--------------------------------------------------------------------------*/\n"
<- "    208 \n"
<- "    209 void type_test ()\n"
<- "    210 {\n"
<- "    211     Holiday holiday;\n"
<- "    212     Date* date = new_date(Sat, 24, 12, 1994);\n"
<- "    213     void* voidptr = date;\n"
<- "    214 \n"
<- "    215     struct Uni {\n"
<- "    216 \tint ii;\n"
<- "    217 \tunion jj {\n"
<- "    218 \t    int j;\n"
<- "    219 \t    char c;\n"
<- "    220 \t} u;\n"
<- "    221     } uni;\n"
<- "    222 \n"
<- "    223     float f  = 0.0;\n"
<- "    224     double d = 0.0;\n"
<- "    225     char sc  = \'a\';\n"
<- "    226 \n"
<- "    227     set_holiday(&holiday, Sat, 31, 12, 1994, \"May all acquaintance be forgot\");\n"
<- "    228 \n"
<- "    229     uni.ii  = 7;\n"
<- "    230     uni.u.j = 9;\n"
<- "    231 }\n"
<- "    232 \n"
<- "    233 /*--------------------------------------------------------------------------*/\n"
<- "    234 void in_out_test ()\n"
<- "    235 {\n"
<- "    236     char name[80];\n"
<- "    237     fprintf(stderr, \"This is stderr speaking\\n"
   "\");\n"
<- "    238     printf(\"What\'s your name? \");\n"
<- "    239     fgets(name, sizeof(name), stdin);\n"
<- "    240 \n"
<- "    241     if (name[strlen(name) - 1] == \'\\n"
   "\')\n"
<- "    242 \tname[strlen(name) - 1] = \'\\0\';\n"
<- "    243 \n"
<- "    244     printf(\"Hello, %s!\\n"
   "\", name);\n"
<- "    245 }\n"
<- "    246 \n"
<- "    247 /*--------------------------------------------------------------------------*/\n"
<- "    248 int main (argc, argv)\n"
<- "    249     int argc;\n"
<- "    250     char *argv[];\n"
<- "    251 {\n"
<- "    252     int i = 42;\n"
<- "    253     tree_test();\n"
<- "    254     i++;\n"
<- "    255     list_test(i);\n"
<- "    256     i++;\n"
<- "    257     array_test();\n"
<- "    258     i++;\n"
<- "    259     type_test();\n"
<- "    260     --i;\n"
<- "    261     in_out_test();\n"
<- "    262     return 0;\n"
<- "    263 }\n"
<- "(ladebug) "
#  Reading file "file" from Ladebug...done.
#  Source "file" (from Ladebug) 263 lines, 6587 characters
#  Setting buttons...
#  Setting buttons...done.
-> "givenfile \n"
<- "\033[J "
<- "givenfile \n"
<- "        ^\n"
<- "Unable to parse input as legal command or C expression.\n"
<- "(ladebug) "
-> "# reset\n"
<- "\033[J "
<- "\033[C\033[D\033[J "
<- "\033[D\033[J "
<- "\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C\n"
<- "(ladebug) "
-> "file\n"
<- "file\n"
<- "\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[C\033[D"
<- "\033[J "
<- "\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\n"
<- "./ctest.c\n"
<- "(ladebug) "
-> "list\n"
<- "\033[J "
<- "\033[C\033[D\033[J "
<- "\033[C\033[D"
<- "\033[J "
<- "\033[D\033[D\033[D\033[J "
<- "\033[C\n"
<- "(File ./ctest.c has only 263 lines; the current line number is 264)\n"
<- "(ladebug) "
-> "status\n"
<- "\033[J "
<- "(ladebug) "
-> "display\n"
<- "\033[J "
<- "\033[C"
<- "\033[D\033[J"
<- " "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[J"
<- " "
<- "display\n"
<- "      ^\n"
<- "Unable to parse input as legal command or C expression.\n"
<- "(ladebug) "
-> "setenv TERM dumb\n"
<- "\033[J "
<- "\033[D\033[J "
<- "\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D"
<- "\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\n"
<- "(ladebug) "
-> "list file:0\n"
<- "\033[J "
<- " "
<- "\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J"
<- " "
<- "\n"
<- "Symbol \"file\" is not defined.\n"
<- "(ladebug) "
-> "givenfile \n"
<- "\033[J "
<- "\033[D\033[D\033[D\033[J "
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D"
<- "\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\n"
<- "given"
<- "file \n"
<- "        ^"
<- "\n"
<- "Unable to parse input as legal command or C expression.\n"
<- "(ladebug) "
#  Creating options in "/home/st01511/.ddd/init"...
#  Creating options in "/home/st01511/.ddd/init"...done.
-> "help detach\n"
<- "\033[J "
<- "\n"
<- "        detach [process_id_list] \n"
<- "\n"
<- "Use the \'detach\' command to detach from a running process you specify \n"
<- "from the process ID list.  Specifying a process ID and detaching from \n"
<- "the process disables your ability to debug the process.  If you do not \n"
<- "specify a process ID from the list, Ladebug detaches from the \n"
<- "current process. \n"
<- "(ladebug) "
-> "help run\n"
<- "\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[J"
<- " "
<- "\033[D"
<- "\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C\033[D\033[D\033[D\033[D\033[D\033[J"
<- " "
<- "\n"
<- "\n"
<- "        run [<program arguments>] [<io redirection>] \n"
<- "        rerun [<program arguments>] [<io redirection>] \n"
<- "\n"
<- "Use the \'run\' and \'rerun\' commands to start program execution. \n"
<- "Enter program flags, options, and input and output redirections \n"
<- "as arguments. If the \'rerun\' command is specified without \n"
<- "arguments, the arguments entered with the previous \'run\' \n"
<- "command are used.  If the last modification time and/or \n"
<- "size of the binary file or any of the shared objects used \n"
<- "by the binary file has changed since the last \'run\' command \n"
<- "was issued,  Ladebug automatically rereads the symbol \n"
<- "table information.  If this happens, the old breakpoint \n"
<- "settings may no longer be valid after the new symbol table \n"
<- "information is read. \n"
<- "(ladebug) "
#  Starting Ladebug...done.
#  Welcome to DDD 3.1.90 "Gravity Pull" (alphaev56-dec-osf4.0d)
-> "help step\n"
<- "\033[J "
<- "\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\n"
<- "        step [<expression>]\n"
<- "\n"
<- "Use the \'next\' and \'step\' commands to execute a line of source \n"
<- "code.  When the next line to be executed contains a function call, \n"
<- "the \'next\' command executes the function being called and returns \n"
<- "to the line immediately after the function call. The \'step\' \n"
<- "command steps into the function and executes only the first line \n"
<- "of the function. \n"
<- "\n"
<- "For multithreaded applications, use these commands to step the \n"
<- "current thread while putting all other threads on hold. \n"
<- "\n"
<- "If the optional <expression> argument is supplied, Ladebug will \n"
<- "evaluate the number of times to execute the command.  The expression \n"
<- "can be any expression that is valid within the current context. \n"
<- "(ladebug) "
-> "help stepi\n"
<- "\033[J "
<- "\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[J "
<- "\n"
<- "        stepi [<expression>]\n"
<- "\n"
<- "Use the \'stepi\' command and the \'nexti\' command to execute a \n"
<- "machine instruction. When the instruction contains a function call, \n"
<- "the \'stepi\' command steps into the function being called, and the \n"
<- "\'nexti\' command executes the function being called. \n"
<- "\n"
<- "For multithreaded applications, use these commands to step the \n"
<- "current thread while putting all other threads on hold. \n"
<- "\n"
<- "If the optional <expression> argument is supplied, Ladebug will \n"
<- "evaluate the number of times to execute the command.  The expression \n"
<- "can be any expression that is valid within the current context. \n"
<- "(ladebug) "
-> "help next\n"
<- "\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\n"
<- "        next [<expression>] \n"
<- "\n"
<- "Use the \'next\' and \'step\' commands to execute a line of source \n"
<- "code.  When the next line to be executed contains a function call, \n"
<- "the \'next\' command executes the function being called and returns \n"
<- "to the line immediately after the function call.  The \'step\' \n"
<- "command executes only the first line of the function. \n"
<- "\n"
<- "For multithreaded applications, use these commands to step the \n"
<- "current thread while putting all other threads on hold. \n"
<- "\n"
<- "If the optional <expression> argument is supplied, Ladebug will \n"
<- "evaluate the number of times to execute the command.  The expression \n"
<- "can be any expression that is valid within the current context. \n"
<- "(ladebug) "
-> "help nexti\n"
<- "\033[J "
<- "\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\n"
<- "        nexti [<expression>] \n"
<- "\n"
<- "Use the \'stepi\' command and the \'nexti\' command to execute a \n"
<- "machine instruction.  When the instruction contains a function \n"
<- "call, the \'stepi\' command steps into the function being called, \n"
<- "and the \'nexti\' command executes the function being called. \n"
<- "\n"
<- "For multithreaded applications, use these commands to step the \n"
<- "current thread while putting all other threads on hold. \n"
<- "\n"
<- "If the optional <expression> argument is supplied, Ladebug will \n"
<- "evaluate the number of times to execute the command.  The expression \n"
<- "can be any expression that is valid within the current context. \n"
<- "(ladebug) "
-> "help until\n"
<- "\033[J "
<- "Information about \"until\" isn\'t available\n"
<- "\n"
<- "\n"
<- "\n"
<- "Welcome to the Ladebug debugger help system. \n"
<- " \n"
<- "To find out about:  \n"
<- " \n"
<- "        - starting up a program in Ladebug \n"
<- "                enter \'help start\' \n"
<- " \n"
<- "        - stopping at a specific place in your program \n"
<- "                enter \'help breakpoint\' \n"
<- " \n"
<- "        - making the program execute \n"
<- "                enter \'help execution\' \n"
<- " \n"
<- "        - determining the type or value of a program variable \n"
<- "                enter \'help variable\' \n"
<- " \n"
<- "        - reading or writing a memory location \n"
<- "                enter \'help memory\' \n"
<- " \n"
<- "        - reading or writing a register \n"
<- "                enter \'help register\' \n"
<- " \n"
<- "        - showing the current call stack \n"
<- "                enter \'help stack\' \n"
<- " \n"
<- "        - displaying the source text of your program \n"
<- "                enter \'help listing\' \n"
<- " \n"
<- "        - listing all of the ladebug commands \n"
<- "                enter \'help ladebug\' or \'help command\' \n"
<- " \n"
<- "To find out about all of the Ladebug commands, use \n"
<- "\'help ladebug\' or \'help command\'.  To find out about  \n"
<- "a specific command, use help, followed by the command  \n"
<- "verb, such as \'help quit\'.\n"
<- "(ladebug) "
-> "help cont\n"
<- "\033[J "
<- "\033[D\033[J "
<- "\n"
<- "        cont [<signal>] [to <line_number>] \n"
<- "        cont [in <function>] \n"
<- "\n"
<- "Use the \'cont\' command without a parameter value to resume program \n"
<- "execution until a breakpoint, a signal, an error, or the end of \n"
<- "the program is encountered.  Specify a signal parameter value to send \n"
<- "an operating system signal to the program continuing execution. \n"
<- "Specify a to line_number parameter value to halt program execution \n"
<- "when that line number is reached. \n"
<- "\n"
<- "When you use the \'cont\' commmand, Ladebug resumes execution of the \n"
<- "entire process. \n"
<- "\n"
<- "The signal parameter value can be either a signal number or a \n"
<- "string name (for example, SIGSEGV).  The default is 0, which \n"
<- "allows the program to continue execution without specifying a \n"
<- "signal.  If you specify a signal parameter value, the program \n"
<- "continues execution with that signal. \n"
<- "\n"
<- "The \'to line_number\' parameter value is used to resume execution and \n"
<- "then halt when the specified source line is reached. \n"
<- "\n"
<- "The form of the optional line_number argument must be one of the \n"
<- "following: \n"
<- "\t- line_number, a positive numeric, which indicates the \n"
<- "           line number of the current source file where execution \n"
<- "           is to be halted \n"
<- "        - \"filename\":line_number, which explicitly identifies both \n"
<- " \t  the source file and the line number where execution \n"
<- "          is to be halted. \n"
<- "\n"
<- "If the optional function name is provided, execution will be halted \n"
<- "when that function is reached.  This form of the \'cont\' command does \n"
<- "not support signals.  If the function name is overloaded, the user is \n"
<- "prompted with a choice of overloaded function names or \'none of the above\'. \n"
<- "Depending on user choice, program execution continues until the \n"
<- "specified function is reached or warns the user that no breakpoint is set.\n"
<- "If the \'none of the above\' option is specified, program execution returns \n"
<- "to the \'ladebug\' prompt.\n"
<- "(ladebug) "
-> "help signal\n"
<- "\033[J "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[J "
<- "Information about \"signal\" isn\'t available\n"
<- "\n"
<- "\n"
<- "\n"
<- "Welcome to the Ladebug debugger help system. \n"
<- " \n"
<- "To find out about:  \n"
<- " \n"
<- "        - starting up a program in Ladebug \n"
<- "                enter \'help start\' \n"
<- " \n"
<- "        - stopping at a specific place in your program \n"
<- "                enter \'help breakpoint\' \n"
<- " \n"
<- "        - making the program execute \n"
<- "                enter \'help execution\' \n"
<- " \n"
<- "        - determining the type or value of a program variable \n"
<- "                enter \'help variable\' \n"
<- " \n"
<- "        - reading or writing a memory location \n"
<- "                enter \'help memory\' \n"
<- " \n"
<- "        - reading or writing a register \n"
<- "                enter \'help register\' \n"
<- " \n"
<- "        - showing the current call stack \n"
<- "                enter \'help stack\' \n"
<- " \n"
<- "        - displaying the source text of your program \n"
<- "                enter \'help listing\' \n"
<- " \n"
<- "        - listing all of the ladebug commands \n"
<- "                enter \'help ladebug\' or \'help command\' \n"
<- " \n"
<- "To find out about all of the Ladebug commands, use \n"
<- "\'help ladebug\' or \'help command\'.  To find out about  \n"
<- "a specific command, use help, followed by the command  \n"
<- "verb, such as \'help quit\'.\n"
<- "(ladebug) "
-> "help kill\n"
<- "\033[J "
<- "\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[J "
<- "\n"
<- "        kill \n"
<- "\n"
<- "Use the \'kill\' command to terminate the program process leaving \n"
<- "the debugger running.  When a process terminates, any breakpoints \n"
<- "and traces previously set are retained.  You can later rerun the \n"
<- "program. \n"
<- "(ladebug) "
-> "help up\n"
<- "\033[J "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[J "
<- "\n"
<- "        up [<integer>] \n"
<- "\n"
<- "Use the \'up\' command or the \'down\' command without an argument to change the \n"
<- "function scope to the function located one level up or down the stack.  \n"
<- "\n"
<- "Enter a number argument to change the function scope to the function \n"
<- "up or down the specified number of levels. If the number of levels \n"
<- "exceeds the number of active functions on the stack, the function \n"
<- "scope moves up or down as many levels as possible and the debugger \n"
<- "issues a warning message. \n"
<- "\n"
<- "When the function scope changes, the debugger displays the source line \n"
<- "corresponding to the last point of execution in that function. \n"
<- "(ladebug) "
-> "help down\n"
<- "\033[J "
<- "\033[D\033[J "
<- "\033[D\033[J "
<- "\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C"
<- "\n"
<- "\n"
<- "        down [<integer>] \n"
<- "\n"
<- "Use the \'up\' command or the \'down\' command without an argument to \n"
<- "change the function scope to the function located one level up or \n"
<- "down the stack. \n"
<- "\n"
<- "Enter a number argument to change the function scope to the \n"
<- "function up or down the specified number of levels.  If the number \n"
<- "of levels exceeds the number of active functions on the stack, \n"
<- "the function scope moves up or down as many levels as possible \n"
<- "and the debugger issues a warning message. \n"
<- "\n"
<- "When the function scope changes, the debugger displays the source \n"
<- "line corresponding to the last point of execution in the function.\n"
<- "(ladebug) "
-> "print -r array_test\n"
<- "\033[J "
<- "\033[C"
<- "\033[D\033[J"
<- " "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C\033[D\033[D\033[D\033[D\033[D\033[J"
<- " "
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C\033[D\033[D\033[D\033[D\033[D\033[J"
<- " "
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C"
<- "\n"
<- "prin"
<- "t -r array_test\n"
<- "                  "
<- "^"
<- "\n"
<- "Unable to parse input as legal command or C expression.\n"
<- "(ladebug) "
-> "file file\n"
<- "\033[J "
<- "File scope as specified: \n"
<- "    file\n"
<- "not found in the binary: \n"
<- "    ctest\n"
<- "Leaving file scope unchanged.\n"
<- "(ladebug) "
-> "status\n"
<- "\033[J "
<- "(ladebug) "
-> "stop at 257\n"
<- "\033[J "
<- "[#1: stop at \"./ctest.c\":257 ]\n"
<- "(ladebug) "
-> "status\n"
<- "\033[J"
<- " "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[J"
<- " "
<- "\033[D\033[J"
<- " "
<- "\033[C\033[C\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\n"
<- "#1 PC==0x120001e14 in int main(int, char**) \"./ctest.c\":257 { break }\n"
<- "(ladebug) "
#  Reading file "/local/home/si/st01511/ddd-3.1.90/ddd/ stop at \"./ctest.c\""...
#  Reading file "/local/home/si/st01511/ddd-3.1.90/ddd/ stop at \"./ctest.c\""...No such file or directory.
-> "setenv EDITOR \"echo\"\n"
<- "\033[J "
<- "\033[C\033[D\033[J"
<- " "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[J"
<- " "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C\033[D\033[D\033[D\033[D\033[D\033[J"
<- " "
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\n"
<- "(ladebug) "
-> "edit  stop at \"./ctest.c\"\n"
<- "\033[J"
<- " "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[J"
<- " "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C\033[D\033[J "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C\n"
<- "edit  "
<- "stop at \"./ctes"
<- "t.c\"\n"
<- "   ^"
<- "\n"
<- "Unable to parse input as legal command or C expression.\n"
<- "(ladebug) "
-> "setenv EDITOR \"xem\"\n"
<- "\033[J"
<- " "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[J"
<- " "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C\033[D\033[D\033[D\033[D\033[D\033[J"
<- " "
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C\n"
<- "(ladebug) "
#  Reading file "ctest.c\"" from Ladebug...
-> "list 1,1000000\n"
<- "\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[J"
<- " "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D"
<- "\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\n"
<- "      1 /* $Id$ */\n"
<- "      2 /* C Test program */\n"
<- "      3 \n"
<- "      4 /*\n"
<- "      5  * Copyright (C) 1995 Technische Universitaet Braunschweig, Germany.\n"
<- "      6  * Written by Andreas Zeller <zeller@gnu.org>.\n"
<- "      7  * \n"
<- "      8  * This file is part of DDD.\n"
<- "      9  * \n"
<- "     10  * DDD is free software; you can redistribute it and/or\n"
<- "     11  * modify it under the terms of the GNU General Public\n"
<- "     12  * License as published by the Free Software Foundation; either\n"
<- "     13  * version 3 of the License, or (at your option) any later version.\n"
<- "     14  * \n"
<- "     15  * DDD is distributed in the hope that it will be useful,\n"
<- "     16  * but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
<- "     17  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n"
<- "     18  * See the GNU General Public License for more details.\n"
<- "     19  * \n"
<- "     20  * You should have received a copy of the GNU General Public\n"
<- "     21  * License along with DDD -- see the file COPYING.\n"
<- "     22  * If not, see <http://www.gnu.org/licenses/>.\n"
<- "     24  * \n"
<- "     25  * DDD is the data display debugger.\n"
<- "     26  * For details, see the DDD World-Wide-Web page, \n"
<- "     27  * `http://www.gnu.org/software/ddd/\',\n"
<- "     28  * or send a mail to the DDD developers <ddd@gnu.org>.\n"
<- "     29  */\n"
<- "     30 \n"
<- "     31 /* --------------------------------------------------------------------------\n"
<- "     32  *  This program defines some data structures and values that may be\n"
<- "     33  *  examined using DDD.\n"
<- "     34  * --------------------------------------------------------------------------\n"
<- "     35  */\n"
<- "     36 \n"
<- "     37 char ctest_rcsid[] =\n"
<- "     38     \"$Id$\";\n"
<- "     39 \n"
<- "     40 #include <stdio.h>\n"
<- "     41 #include <stdlib.h>\n"
<- "     42 #include <string.h>\n"
<- "     43 \n"
<- "     44 typedef enum _DayOfWeek {Sun, Mon, Tue, Wed, Thu, Fri, Sat} DayOfWeek;\n"
<- "     45 \n"
<- "     46 int a_global = 42;\t/* Place watchpoints on this one */\n"
<- "     47 \n"
<- "     48 typedef struct Date {\n"
<- "     49     DayOfWeek day_of_week;\n"
<- "     50     int day;\n"
<- "     51     int month;\n"
<- "     52     int year;\n"
<- "     53 } Date;\n"
<- "     54 \n"
<- "     55 void set_date(d, day_of_week, day, month, year)\n"
<- "     56     Date *d;\n"
<- "     57     DayOfWeek day_of_week;\n"
<- "     58     int day, month, year;\n"
<- "     59 {\n"
<- "     60     d->day_of_week = day_of_week;\n"
<- "     61     d->day         = day;\n"
<- "     62     d->month       = month;\n"
<- "     63     d->year        = year;\n"
<- "     64 }\n"
<- "     65 \n"
<- "     66 Date *new_date(day_of_week, day, month, year)\n"
<- "     67     DayOfWeek day_of_week;\n"
<- "     68     int day, month, year;\n"
<- "     69 {\n"
<- "     70     Date *date = (Date *)malloc(sizeof(Date));\n"
<- "     71     set_date(date, day_of_week, day, month, year);\n"
<- "     72 \n"
<- "     73     return date;\n"
<- "     74 }\n"
<- "     75 \n"
<- "     76 void free_date(date)\n"
<- "     77     Date *date;\n"
<- "     78 {\n"
<- "     79     free(date);\n"
<- "     80 }\n"
<- "     81 \n"
<- "     82 /*--------------------------------------------------------------------------*/\n"
<- "     83 typedef struct _Holiday {\n"
<- "     84     Date date;\n"
<- "     85     char *name;\n"
<- "     86 } Holiday;\n"
<- "     87 \n"
<- "     88 void set_holiday(d, day_of_week, day, month, year, name)\n"
<- "     89     Holiday *d;\n"
<- "     90     DayOfWeek day_of_week;\n"
<- "     91     int day, month, year;\n"
<- "     92     char *name;\n"
<- "     93 {\n"
<- "     94     set_date(&d->date, day_of_week, day, month, year);\n"
<- "     95     d->name = name;\n"
<- "     96     a_global = 1;\n"
<- "     97 }\n"
<- "     98 \n"
<- "     99 /*--------------------------------------------------------------------------*/\n"
<- "    100 typedef struct _Tree {\n"
<- "    101     int   value;\n"
<- "    102     char *name;\n"
<- "    103 \n"
<- "    104     Date date;\n"
<- "    105     struct _Tree *left;\n"
<- "    106     struct _Tree *right;\n"
<- "    107 } Tree;\n"
<- "    108 \n"
<- "    109 Tree *new_tree(value, name)\n"
<- "    110     int value;\n"
<- "    111     char *name;\n"
<- "    112 {\n"
<- "    113     Tree *tree = (Tree *)malloc(sizeof(Tree));\n"
<- "    114     tree->value = value;\n"
<- "    115     tree->name  = name;\n"
<- "    116     tree->left  = NULL;\n"
<- "    117     tree->right = NULL;\n"
<- "    118 \n"
<- "    119     return tree;\n"
<- "    120 }\n"
<- "    121 \n"
<- "    122 void free_tree(tree)\n"
<- "    123     Tree *tree;\n"
<- "    124 {\n"
<- "    125     if (tree->left)\n"
<- "    126 \tfree_tree(tree->left);\n"
<- "    127     if (tree->right)\n"
<- "    128 \tfree_tree(tree->right);\n"
<- "    129 \n"
<- "    130     free(tree);\n"
<- "    131 }\n"
<- "    132 \n"
<- "    133 /*--------------------------------------------------------------------------*/\n"
<- "    134 typedef struct _List {\n"
<- "    135     int value;\n"
<- "    136 \n"
<- "    137     struct _List *self;\n"
<- "    138     struct _List *next;\n"
<- "    139 } List;\n"
<- "    140 \n"
<- "    141 List *new_list(value)\n"
<- "    142     int value;\n"
<- "    143 {\n"
<- "    144     List *list = (List *)malloc(sizeof(List));\n"
<- "    145     list->value = value;\n"
<- "    146     list->self  = list;\n"
<- "    147     list->next  = list;\n"
<- "    148 \n"
<- "    149     return list;\n"
<- "    150 }\n"
<- "    151 \n"
<- "    152 /*--------------------------------------------------------------------------*/\n"
<- "    153 void tree_test ()\n"
<- "    154 {\n"
<- "    155     Tree *tree = NULL;\n"
<- "    156     tree =              new_tree (7, \"Ada\");      /* Byron Lovelace */\n"
<- "    157     tree->left =        new_tree (1, \"Grace\");    /* Murray Hopper  */\n"
<- "    158     tree->left->left =  new_tree (5, \"Judy\");     /* Clapp          */\n"
<- "    159     tree->left->right = new_tree (6, \"Kathleen\"); /* McNulty        */\n"
<- "    160     tree->right =       new_tree (9, \"Mildred\");  /* Koss           */\n"
<- "    161 \n"
<- "    162     set_date(&tree->date, Tue, 29, 11, 1994);\n"
<- "    163     set_date(&tree->date, Wed, 30, 11, 1994);\n"
<- "    164 \n"
<- "    165     free_tree(tree);\n"
<- "    166 }\n"
<- "    167 \n"
<- "    168 /*--------------------------------------------------------------------------*/\n"
<- "    169 void list_test(start)\n"
<- "    170     int start;\n"
<- "    171 {\n"
<- "    172     List *list = 0;\n"
<- "    173 \n"
<- "    174     list                         = new_list(a_global + start++);\n"
<- "    175     list->next                   = new_list(a_global + start++);\n"
<- "    176     list->next->next             = new_list(a_global + start++);\n"
<- "    177     list->next->next->next       = list;\n"
<- "    178 \n"
<- "    179     free(list->next->next);\n"
<- "    180     free(list->next);\n"
<- "    181     free(list);\n"
<- "    182 }\n"
<- "    183 \n"
<- "    184 /*--------------------------------------------------------------------------*/\n"
<- "    185 void array_test ()\n"
<- "    186 {\n"
<- "    187     int i;\n"
<- "    188     static DayOfWeek days_of_week[7] = {Sun, Mon, Tue, Wed, Thu, Fri, Sat};\n"
<- "    189 \n"
<- "    190     static char* twodim [2][3] = {{ \"Pioneering\", \"women\", \"in\"},\n"
<- "    191 \t\t\t\t  { \"computer\", \"science\", \"!\"}};\n"
<- "    192 \n"
<- "    193     Date dates[4];\n"
<- "    194     Date* date_ptrs[4];\n"
<- "    195     date_ptrs[0] = new_date (Thu, 1, 9, 1994);\n"
<- "    196     date_ptrs[1] = new_date (Tue, 10, 5, 1994);\n"
<- "    197     date_ptrs[2] = new_date (Fri, 15, 7, 1994);\n"
<- "    198     date_ptrs[3] = new_date (Sat, 24, 12, 1994);\n"
<- "    199 \n"
<- "    200     for (i = 0; i < 4; i++)\n"
<- "    201     {\n"
<- "    202 \tdates[i] = *date_ptrs[i];\n"
<- "    203 \tfree_date(date_ptrs[i]);\n"
<- "    204     }\n"
<- "    205 }\n"
<- "    206 \n"
<- "    207 /*--------------------------------------------------------------------------*/\n"
<- "    208 \n"
<- "    209 void type_test ()\n"
<- "    210 {\n"
<- "    211     Holiday holiday;\n"
<- "    212     Date* date = new_date(Sat, 24, 12, 1994);\n"
<- "    213     void* voidptr = date;\n"
<- "    214 \n"
<- "    215     struct Uni {\n"
<- "    216 \tint ii;\n"
<- "    217 \tunion jj {\n"
<- "    218 \t    int j;\n"
<- "    219 \t    char c;\n"
<- "    220 \t} u;\n"
<- "    221     } uni;\n"
<- "    222 \n"
<- "    223     float f  = 0.0;\n"
<- "    224     double d = 0.0;\n"
<- "    225     char sc  = \'a\';\n"
<- "    226 \n"
<- "    227     set_holiday(&holiday, Sat, 31, 12, 1994, \"May all acquaintance be forgot\");\n"
<- "    228 \n"
<- "    229     uni.ii  = 7;\n"
<- "    230     uni.u.j = 9;\n"
<- "    231 }\n"
<- "    232 \n"
<- "    233 /*--------------------------------------------------------------------------*/\n"
<- "    234 void in_out_test ()\n"
<- "    235 {\n"
<- "    236     char name[80];\n"
<- "    237     fprintf(stderr, \"This is stderr speaking\\n"
   "\");\n"
<- "    238     printf(\"What\'s your name? \");\n"
<- "    239     fgets(name, sizeof(name), stdin);\n"
<- "    240 \n"
<- "    241     if (name[strlen(name) - 1] == \'\\n"
   "\')\n"
<- "    242 \tname[strlen(name) - 1] = \'\\0\';\n"
<- "    243 \n"
<- "    244     printf(\"Hello, %s!\\n"
   "\", name);\n"
<- "    245 }\n"
<- "    246 \n"
<- "    247 /*--------------------------------------------------------------------------*/\n"
<- "    248 int main (argc, argv)\n"
<- "    249     int argc;\n"
<- "    250     char *argv[];\n"
<- "    251 {\n"
<- "    252     int i = 42;\n"
<- "    253     tree_test();\n"
<- "    254     i++;\n"
<- "    255     list_test(i);\n"
<- "    256     i++;\n"
<- "    257     array_test();\n"
<- "    258     i++;\n"
<- "    259     type_test();\n"
<- "    260     --i;\n"
<- "    261     in_out_test();\n"
<- "    262     return 0;\n"
<- "    263 }\n"
<- "(ladebug) "
#  Reading file "ctest.c\"" from Ladebug...done.
#  Source "ctest.c\"" (from Ladebug) 263 lines, 6587 characters
-> "commands\n"
<- "\033[J "
<- "\033[D\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\n"
<- "com"
<- "mands\n"
<- "       ^"
<- "\n"
<- "Unable to parse input as legal command or C expression.\n"
<- "(ladebug) "
-> "setenv TERM dumb\n"
<- "\033[J "
<- "\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[J "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J"
<- " "
<- "\n"
<- "(ladebug) "
-> "rerun \n"
<- "\033[J "
<- "[1] stopped at [main:257 0x120001e14]\t\n"
<- "    257     array_test();\n"
<- "(ladebug) "
-> "file\n"
<- "\033[J"
<- " "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[J"
<- " "
<- "\n"
<- "./ctest.c\n"
<- "(ladebug) "
-> "status\n"
<- "status\n"
<- "\033[J"
<- " "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[J"
<- " "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\n"
<- "#1 PC==0x120001e14 in int main(int, char**) \"./ctest.c\":257 { break }\n"
<- "(ladebug) "
-> "frame\n"
<- "\033[J"
<- " "
<- "\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J"
<- " "
<- "\n"
<- "fra"
<- "me\n"
<- "    ^"
<- "\n"
<- "Unable to parse input as legal command or C expression.\n"
<- "(ladebug) "
-> "print -r i\n"
<- "\033[J "
<- "\033[C"
<- "\033[D"
<- "\033[J "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\n"
<- "pr"
<- "int -r i\n"
<- "         ^"
<- "\n"
<- "Unable to parse input as legal command or C expression.\n"
<- "(ladebug) "
-> "print -r array_test\n"
<- "\033[J "
<- "\033[C"
<- "\033[D\033[J"
<- " "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[J"
<- " "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J"
<- " "
<- "\033[D\033[J"
<- " "
<- "\033[C\033[C\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[D"
<- "\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J"
<- " "
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[D\033[D\033[J"
<- " "
<- "\033[D\033[J"
<- " "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[C\033[C\033[C\033[C\033[C\033[D\033[D\033[D\033[D\033[D\033[J "
<- "\033[C\033[D\033[J"
<- " "
<- "\n"
<- "pri"
<- "nt -r array_tes"
<- "t\n"
<- "                  ^"
<- "\n"
<- "Unable to parse input as legal command or C expression.\n"
<- "(ladebug) "
-> "print -r i\n"
<- "\033[J "
<- "print -r i\n"
<- "         ^\n"
<- "Unable to parse input as legal command or C expression.\n"
<- "(ladebug) "
-> "status\n"
<- "\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[D\033[D\033[D\033[J "
<- "\033[C"
<- "\033[D\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "#1 PC==0x120001e14 in int main(int, char**) \"./ctest.c\":257 { break }\n"
<- "(ladebug) "
-> "quit\n"
<- "\033[J "
#  Running Ladebug (pid 17678, tty /dev/ttyP0)...Exit 0.
#  Saving history in "/home/st01511/.ddd/history"...
#  Saving history in "/home/st01511/.ddd/history"...done.
#  Thanks for using DDD 3.1.90!
