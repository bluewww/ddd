From jos@GBF.DE  Thu Aug 13 15:33:02 1998
From: Jochen Schuetze <jos@GBF.DE>
Subject: Re: Minor problems with ddd 3.0 on DEC OSF with dbx
To: Andreas Zeller <zeller@ips.cs.tu-bs.de>
cc: DDD Maintainers <ddd-bugs@ips.cs.tu-bs.de>
Date: Thu, 13 Aug 1998 15:32:53 +0200 (MEST)
Reply-To: jos@GBF.DE
X-Sender: jos@bvt4027.gbf-braunschweig.de
In-Reply-To: <ogk94d6p6w.fsf@infbssts.ips.cs.tu-bs.de>
Message-ID: <Pine.LNX.3.95.980813145551.316H-200000@bvt4027.gbf-braunschweig.de>
MIME-Version: 1.0

[1  <text/plain; ISO-8859-1 (quoted-printable)>]

Hi Andreas,   (was it right to Cc "ddd-bugs@..." again?)

thanks for your immediate reply -- I hope I can help you trace down
the problem...I'll do my best.

First of all I should include more detailed information about my "dbx".
Unfortunately it's not so very verbous about version information.
All I can find out is that it is part of the operating system,
and "uname -a" produces: OSF1 rzws01 V4.0 878 alpha
[later: dbx comes up with the following banner:
 dbx version 3.11.10]

> > [ This paragraph was more intended for ddd-users... ]
> > How can I pass particular environment settings to the debuggee?
> There should be a DBX command for this.  Can you invoke your program
Certainly you are right and I found it:
At the dbx prompt, I can simply type:
(dbx) setenv VARIABLE "valuetext"

(I had some more problems because my program is called through a shell script,
so attaching to a running process is surely the best way for me..)

> Yep, `list' is the way DDD finds out where the current exec position
> is; `list FUNC' is used by DDD to find out the location of function
Unfortunately Digital UNIX dbx uses different syntax and meaning for "list"
(I include some dialog I had with dbx here...):
<<<<<<<<<<<<<<<<<
(dbx) help list
list <exp>,<exp>               - list source lines from <exp> to <exp>
list <exp>:<int>               - list source lines at <exp> for <int> lines
list <exp>                     - list lines at <exp> for $listwindow lines
list                           - list lines at $cursrcline for $listwindow lines
(dbx)
>>>>>>>>>>>>>>>>>
So I'm afraid it'll be difficult to include full support for this flavour
of dbx into ddd..(?)

Some more details -- in case they might help...
If I call dbx manually, the following happens:
(The name of the binary is fluent.4.4.7...)
<<<<<<<<<<<<<<<<<<<
% dbx fluent.4.4.7
dbx version 3.11.10
Type 'help' for help.

fluent:  Source not available
(dbx)
>>>>>>>>>>>>>>>>>>>
So dbx doesn't know anything about the source file...
(The case is a bit difficult because most parts of the binary consist
of code from ".a" libraries which I don't have any source code for.

I now started my Fluent and then "ddd fluent.4.4.7 -pid ..." to attach
to the running process. Then I told dbx the correct filename of my source
file by entering "file user.f" into the DDD-debugger-console.
After defining a breakpoint with the typed command "stop at 105",
I could say "cont" and the program continued until the breakpoint was hit.

By then, the visible dialog in the debugger console was:
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
DDD 3.0 (alphaev56-dec-osf4.0d), by Dorothea Luetkehaus and Andreas Zeller.
Copyright © 1998 Technische Universitaet Braunschweig, Germany.
dbx version 3.11.10
Type 'help' for help.

thread 0x5 stopped at>*[__poll, 0x3ff801100c8] 	beq	r19, 0x3ff801100e0
(dbx) file user.f
(dbx) stop at 1561
[2] stop at "user.f":1561
(dbx) cont
[2] thread 0x5 stopped at   [usrexc:1561 ,0x120092d70]  $FNSCAL(L,FLUSES + 2) = (TIMEEX - TIMEEN) * FLOWP
list 1,1000000
(dbx)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
(I just realize that ddd obviously found out the correct use of "list"...)

Finally, I pointed to some variables, and now I will stop ddd and include
the whole log file as an attachment.

Maybe you could introduce some switch to suppress the use of the "list"
command? DDD would then have to have the user load the source manually.

> This is an echo problem.  DDD can somewhat compensate for this, but
> not perfectly.  Some DBXes are known for echoing regardless of TTY
> settings, and there is not much I can do about it -- see below.

Just two silly ideas:
Might it help to do the "stty" call before dbx is invoked?
Could you maybe try first, how the particular dbx in use
behaves and choose appropriate TTY settings then?
(You maybe realize that I don't really know what I'm talking about
 -- forgive me for suggesting to the wizard..)

> > PS.: Did you ever play "--russian-roulette" yourself??
> Yes, sure.  (You didn't expect this to work, did you?)
Well, I admit that I didn't dare a try...

If I can help you further by any means, I'd really like to do so,
because I really think ddd deserves help by ANYbody!

By looking at the log file I got a real impression of how much is
going on behind the scenes all the time...

Thanks for all your efforts!

Jochen

[2 log <text/plain; US-ASCII (base64)>]
DDD 3.0 (alphaev56-dec-osf4.0d), Copyright (C) 1998 TU Braunschweig.
Compiled with GCC 2.8.1, libstdc++ 2.8.1
Requires X11R6, Xt11R6, Motif 1.2.4 (OSF/Motif Version 1.2.4)
Includes DDD core, manual, app-defaults, XPM 3.4.1, Athena Panner
Built 1998-06-22 by Thomas Leitner <tom@finwds01.tu-graz.ac.at>.
$  ddd-3.0-alpha-dec-osf4.0d ./fluent.4.4.7 -pid 23185
+  /bin/sh -c 'exec dbx '\''./fluent.4.4.7'\'' '\''-pid'\'' '\''23185'\'''
#  Hello, world!
#  Starting DBX...
#  Enabling core dumps...
#  Enabling core dumps...done.
#  Running DBX (pid 23224, tty /dev/ttyp5)...
<- "dbx version 3.11.10\n"
<- "Type \'help\' for help.\n"
<- "\n"
<- "thread 0x5 stopped at>*[__poll, 0x3ff801100c8] \tbeq\tr19, 0x3ff801100e0\n"
<- "(dbx) "
-> "sh stty -echo -onlcr\n"
<- "sh stty -echo -onlcr\r\n"
#  DBX is running in echo mode.
<- "Cannot change mode of \"/dev/ttyp5\".\r\n"
<- "(dbx) "
-> "set $page = 1\n"
<- "set $page = 1\r\n"
<- "(dbx) "
-> "frame\n"
<- "frame\r\n"
<- "frame\r\n"
<- "     ^ syntax error\r\n"
<- "(dbx) "
-> "func\n"
<- "func\r\n"
<- "__poll\r\n"
<- "(dbx) "
-> "dbxenv run_io\n"
<- "dbxenv run_io\r\n"
<- "dbxenv run_io\r\n"
<- "       ^ syntax error\r\n"
<- "(dbx) "
-> "print -r 4711\n"
<- "print -r 4711\r\n"
<- "print -r 4711\r\n"
<- "         ^ syntax error\r\n"
<- "(dbx) "
-> "where -h\n"
<- "where -h\r\n"
<- "where -h\r\n"
<- "      ^ syntax error\r\n"
<- "(dbx) "
-> "display\n"
<- "display\r\n"
<- "display\r\n"
<- "       ^ syntax error\r\n"
<- "(dbx) "
-> "clear\n"
<- "clear\r\n"
<- "clear\r\n"
<- "     ^ syntax error\r\n"
<- "(dbx) "
-> "help handler\n"
<- "help handler\r\n"
<- "\r\n"
<- "Invalid keyword handler\r\n"
<- "\r\n"
<- "(dbx) "
-> "pwd\n"
<- "pwd\r\n"
<- "\r\n"
<- "\"/usr/include/pwd.h\" not defined or not active\r\n"
<- "(dbx) "
-> "help setenv\n"
<- "help setenv\r\n"
<- "setenv name \"string\"\t       - set environment variable <name> to <string>\r\n"
<- "(dbx) "
-> "help edit\n"
<- "help edit\r\n"
<- "edit                           - invoke editor on current file\r\n"
<- "edit <file>                    - invoke editor on file\r\n"
<- "(dbx) "
-> "help make\n"
<- "help make\r\n"
<- "\r\n"
<- "Invalid keyword make\r\n"
<- "\r\n"
<- "(dbx) "
-> "help regs\n"
<- "help regs\r\n"
<- "\r\n"
<- "Invalid keyword regs\r\n"
<- "\r\n"
<- "(dbx) "
-> "help examine\n"
<- "help examine\r\n"
<- "\r\n"
<- "Invalid keyword examine\r\n"
<- "\r\n"
<- "(dbx) "
-> "language\n"
<- "language\r\n"
<- "\r\n"
<- "Invalid keyword language\r\n"
<- "\r\n"
<- "(dbx) "
-> "print \"DDD\"\n"
<- "print \"DDD"
<- "\"\r\n"
<- "DDD \r\n"
<- "(dbx) "
-> "help when\n"
<- "help "
<- "when\r\n"
<- "when <exp> { <command_list> }  - when <exp> is true, execute command_list\r\n"
<- "when at <line>{<command_list>} - when reach <line>, execute command_list\r\n"
<- "when in <proc>{<command_list>} - when reach <proc>, execute command_list\r\n"
<- "(dbx) "
-> "delete 4711 4711\n"
<- "delete 4711 4711\r\n"
<- "delete 4711 4711\r\n"
<- "            ^ syntax error\r\n"
<- "(dbx) "
-> "help run\n"
<- "help run\r\n"
<- "run arg1 arg2 ... < f1 >& f2   - begin execution of the program\r\n"
<- "(dbx) "
-> "help givenfile\n"
<- "help givenfile\r\n"
<- "\r\n"
<- "Invalid keyword givenfile\r\n"
<- "\r\n"
<- "(dbx) "
-> "help cont\n"
<- "help cont\r\n"
<- "[n] cont                       - continue execution\r\n"
<- "[n] cont <signal>              - continue with signal\r\n"
<- "cont to <line>                 - continue until <line> is reached\r\n"
<- "\t\t\t\t(temporary breakpoint)\r\n"
<- "cont in <proc>                 - continue until <proc> is reached  (see above)\r\n"
<- "cont <signal> to <line>        - continue with signal until <line> (see above)\r\n"
<- "cont <signal> in <proc>        - continue with signal until <proc> (see above)\r\n"
<- "(dbx) "
-> "sh pwd\n"
<- "sh pwd\r\n"
<- "Cannot change mode of \"/dev/ttyp5\".\r\n"
<- "/users/jos/misi/grorue/Sources\r\n"
<- "(dbx) "
-> "file\n"
<- "file\r\n"
<- "fluent.F\r\n"
<- "(dbx) "
-> "list\n"
<- "list\r\n"
<- "\t Source not available\r\n"
<- "(dbx) "
-> "status\n"
<- "status\r\n"
<- "(dbx) "
-> "list fluent.F:0\n"
<- "list fluent.F:0\r\n"
<- "\"F\" is not defined in fluent.fluent.fluent\r\n"
<- "(dbx) "
-> "debug \n"
<- "debug \r\n"
<- "\r\n"
<- "\"debug\" is not defined\r\n"
<- "\r\n"
<- "(dbx) "
-> "sh stty -echo -onlcr\n"
<- "sh stty -echo -onlcr\r\n"
<- "Cannot change mode of \"/dev/ttyp5\".\r\n"
<- "(dbx) "
-> "# reset\n"
<- "# reset\r\n"
<- "# reset\r\n"
<- "       ^ syntax error\r\n"
<- "(dbx) "
-> "file\n"
<- "file\r\n"
<- "fluent.F\r\n"
<- "(dbx) "
-> "list\n"
<- "list\r\n"
<- "\t Source not available\r\n"
<- "(dbx) "
-> "status\n"
<- "status\r\n"
<- "(dbx) "
-> "debug \n"
<- "debug \r\n"
<- "\r\n"
<- "\"debug\" is not defined\r\n"
<- "\r\n"
<- "(dbx) "
-> "help detach\n"
<- "help detach\r\n"
<- "detach [<exp>]\t\t\t- detach from process with pid <exp> or\r\n"
<- "\t\t\t\t  current process; process continues running\r\n"
<- "(dbx) "
#  Starting DBX...done.
#  Welcome to DDD 3.0!
-> "help run\n"
<- "help run\r\n"
<- "run arg1 arg2 ... < f1 >& f2   - begin execution of the program\r\n"
<- "(dbx) "
-> "help step\n"
<- "help step\r\n"
<- "step <int>                     - single step n lines (assumes 1 for <int>)\r\n"
<- "(dbx) "
-> "help stepi\n"
<- "help stepi\r\n"
<- "stepi <exp>                    - single step <exp> assembly instructions\r\n"
<- "(dbx) "
-> "help next\n"
<- "help next\r\n"
<- "next <int>                     - step over next line n times (assumes 1)\r\n"
<- "(dbx) "
-> "help nexti\n"
<- "help nexti\r\n"
<- "nexti <exp>                    - step over next instruction <exp>times(see next)\r\n"
<- "(dbx) "
-> "help until\n"
<- "help until\r\n"
<- "\r\n"
<- "Invalid keyword until\r\n"
<- "\r\n"
<- "(dbx) "
-> "help finish\n"
<- "help finish\r\n"
<- "\r\n"
<- "Invalid keyword finish\r\n"
<- "\r\n"
<- "(dbx) "
-> "help cont\n"
<- "help cont\r\n"
<- "[n] cont                       - continue execution\r\n"
<- "[n] cont <signal>              - continue with signal\r\n"
<- "cont to <line>                 - continue until <line> is reached\r\n"
<- "\t\t\t\t(temporary breakpoint)\r\n"
<- "cont in <proc>                 - continue until <proc> is reached  (see above)\r\n"
<- "cont <signal> to <line>        - continue with signal until <line> (see above)\r\n"
<- "cont <signal> in <proc>        - continue with signal until <proc> (see above)\r\n"
<- "(dbx) "
-> "help signal\n"
<- "help signal\r\n"
<- "\r\n"
<- "Invalid keyword signal\r\n"
<- "\r\n"
<- "(dbx) "
-> "help kill\n"
<- "help kill\r\n"
<- "\r\n"
<- "Invalid keyword kill\r\n"
<- "\r\n"
<- "(dbx) "
-> "help up\n"
<- "help up\r\n"
<- "up <exp>                       - move up <exp> activation levels in the stack\r\n"
<- "(dbx) "
-> "help down\n"
<- "help"
<- " down\r\n"
<- "down <exp>                     - move down <exp> activation levels in the stack\r\n"
<- "(dbx) "
-> "file user.f\n"
<- "file user.f\r\n"
<- "(dbx) "
-> "status\n"
<- "statu"
<- "s\r\n"
<- "(dbx) "
-> "stop at 1561\n"
<- "stop at 1561\r\n"
<- "[2] stop at \"user.f\":1561\r\n"
<- "(dbx) "
-> "status\n"
<- "status\r\n"
<- "[2] "
<- "stop at \"user.f\":1561\r\n"
<- "\r\n"
<- "(dbx) "
-> "list main\n"
<- "list main\r\n"
<- "\t Source not available\r\n"
<- "(dbx) "
-> "cont\n"
<- "cont\r\n"
<- "[2] thread 0x5 stopped at   [usrexc:1561 ,0x120092d70]"
<- " \t"
<- "$FNSCAL(L,FLUSES + 2) = (TIMEEX - TIMEEN) * FLOWP\n"
<- "(dbx) "
-> "file\n"
<- "f"
<- "i"
<- "l"
<- "e"
<- "\r\n"
<- "./user.f\r\n"
<- "(dbx) "
-> "status\n"
<- "s"
<- "t"
<- "a"
<- "t"
<- "u"
<- "s"
<- "\r\n"
<- "[2] "
<- "stop"
<- " at "
<- "\""
<- "u"
<- "s"
<- "e"
<- "r"
<- "."
<- "f"
<- "\""
<- ":"
<- "1561"
<- "\r\n"
<- "\r\n"
<- "(dbx) "
#  Reading file "/users/jos/misi/grorue/Sources/user.f"...
#  Reading file "/users/jos/misi/grorue/Sources/user.f"...done.
#  File "/users/jos/misi/grorue/Sources/user.f" 4179 lines, 121803 characters
#  Reading file "/users/jos/misi/grorue/Sources/file"...
#  Reading file "/users/jos/misi/grorue/Sources/file"...No such file or directory.
-> "setenv EDITOR echo\n"
<- "setenv EDITOR echo\r\n"
<- "(dbx) "
-> "edit file\n"
<- "e"
<- "d"
<- "i"
<- "t"
<- " "
<- "f"
<- "i"
<- "l"
<- "e"
<- "\r\n"
<- "\r\n"
<- "\"file\" not defined or not active"
<- "\r\n"
<- "(dbx) "
-> "setenv EDITOR /usr/bin/vi\n"
<- "s"
<- "e"
<- "t"
<- "e"
<- "n"
<- "v"
<- " "
<- "E"
<- "D"
<- "I"
<- "T"
<- "O"
<- "R"
<- " "
<- "/"
<- "usr/bin/vi\r\n"
<- "setenv E"
<- "DITOR /u"
<- "sr/bin/v"
<- "i\r\n"
<- " "
<- " "
<- " "
<- " "
<- " "
<- " "
<- " "
<- " "
<- " "
<- " "
<- " "
<- " "
<- " "
<- " "
<- "^ syntax"
<- " error"
<- "\r\n"
<- "(dbx) "
#  Reading file "file" from DBX...
-> "list 1,1000000\n"
<- "l"
<- "i"
<- "s"
<- "t"
<- " "
<- "1"
<- ","
<- "1"
<- "0"
<- "0"
<- "0"
<- "0"
<- "0"
<- "0"
<- "\r\n"
<- " "
<- " "
<- "   1  "
<- "      SUBROUTINE ANALYT( step, alfa)\r\n"
<- " "
<- " "
<- "   2  "
<- "      REAL XX(6)\r\n"
<- " "
<- " "
<- "   3  "
<- "      REAL YY(6)\r\n"
<- " "
<- " "
<- "   4  "
<- "      REAL TINI\r\n"
<- " "
<- " "
<- "   5  "
<- "      REAL UGAS(3)\r\n"
<- " "
<- " "
<- "   6  "
<- "      REAL UFLUC(3)\r\n"
<- " "
<- " "
<- "   7  "
<- "      REAL UTOT(3)\r\n"
<- " "
<- " "
<- "   8  "
<- "      REAL ALFS\r\n"
<- " "
<- " "
<- "   9  "
<- "      REAL UGET(3)\r\n"
<- " "
<- " "
<- "  10  "
<- "      REAL VDR(3)\r\n"
<- " "
<- " "
<- "  11  "
<- "      REAL DRIFT(3)\r\n"
<- " "
<- " "
<- "  12  "
<- "      REAL DRFTOL(3)\r\n"
<- " "
<- " "
<- "  13  "
<- "      real vrel\r\n"
<- " "
<- " "
<- "  14  "
<- "      logical lrwlk\r\n"
<- " "
<- " "
<- "  15  "
<- "      COMMON /P2STAT/ XX, YY, UGAS, UFLUC, UTOT, vrel,  \r\n"
<- " "
<- " "
<- "  16  "
<- "     &          UGET, VDR, ALFS, DRIFT, DRFTOL, TINI, lrwlk\r\n"
<- "    17        INTEGER  IGRTYP\r\n"
<- "    18        INTEGER  ICOSYS\r\n"
<- "    19        INTEGER  IDIMEN\r\n"
<- "    20        INTEGER  NI\r\n"
<- "    21        INTEGER  NJ\r\n"
<- "    22        INTEGER  NK\r\n"
<- "More (n if no)?"
-> "\n"
<- "    23        REAL     RANNUL\r\n"
<- "    24        INTEGER  ICOORD\r\n"
<- "    25        COMMON /GRID/ IGRTYP, ICOSYS, IDIMEN, NI, NJ, NK, RANNUL, ICOORD\r\n"
<- "    26        REAL    GREAT\r\n"
<- "    27        REAL    HUGE\r\n"
<- "    28  "
<- "      REAL    SMALL\r\n"
<- "    29        REAL    SMALLA\r\n"
<- "    30        REAL    SMALLV\r\n"
<- "    31        COMMON /BIGSML/ SMALL, SMALLA, SMALLV, GREAT, HUGE\r\n"

!!!!!!!!!!! Cut out all the uninteresting stuff...

<- "  4178         RETURN\r\n"
<- "  4179         END\r\n"
<- "More (n if no)?"
-> "\n"
<- "(dbx) "
#  Reading file "file" from DBX...done.
#  Source "file" (from DBX) 4179 lines, 121803 characters
-> "print \"FLUSES =\", FLUSES\n"
<- "print \"FLUSES =\", FLUSES\r\n"
<- "FLUSES ="
<- " "
<- "\r\n"
<- "\"FLUSES\" is not defined or not active"
<- "\r\n"
<- "(dbx) "
-> "print \"NINJCT =\", NINJCT\n"
<- "print \"N"
<- "I"
<- "N"
<- "J"
<- "C"
<- "T"
<- " "
<- "="
<- "\""
<- ","
<- " "
<- "N"
<- "I"
<- "N"
<- "J"
<- "C"
<- "T"
<- "\r\n"
<- "NINJCT ="
<- " "
<- "8"
<- " \r\n"
<- "(dbx) "
-> "print \"NAMSIZ =\", NAMSIZ\n"
<- "p"
<- "r"
<- "i"
<- "n"
<- "t"
<- " "
<- "\""
<- "N"
<- "A"
<- "M"
<- "S"
<- "I"
<- "Z"
<- " "
<- "="
<- "\""
<- ","
<- " "
<- "N"
<- "A"
<- "M"
<- "S"
<- "I"
<- "Z"
<- "\r\n"
<- "NAMSIZ ="
<- " "
<- "\r\n"
<- "\"NAMSIZ\" is not defined or not active"
<- "\r\n"
<- "(dbx) "
-> "print \"NUMKPT =\", NUMKPT\n"
<- "print \"NUMKPT =\", NUMKPT\r\n"
<- "NUMKPT ="
<- " 500 \r\n"
<- "(dbx) "
-> "print \"END =\", END\n"
<- "print"
<- " "
<- "\""
<- "E"
<- "N"
<- "D"
<- " "
<- "="
<- "\""
<- ","
<- " "
<- "E"
<- "N"
<- "D"
<- "\r\n"
<- "END ="
<- " "
<- "1078031968"
<- " \r\n"
<- "(dbx) "
-> "print \"FIXMAX =\", FIXMAX\n"
<- "p"
<- "r"
<- "i"
<- "n"
<- "t"
<- " "
<- "\""
<- "F"
<- "I"
<- "X"
<- "M"
<- "A"
<- "X"
<- " "
<- "="
<- "\""
<- ","
<- " "
<- "F"
<- "I"
<- "X"
<- "M"
<- "A"
<- "X"
<- "\r\n"
<- "FIXMAX ="
<- " "
<- "\r\n"
<- "\"FIXMAX\" is not defined or not active"
<- "\r\n"
<- "(dbx) "
-> "print \"ENDIF =\", ENDIF\n"
<- "print"
<- " "
<- "\""
<- "E"
<- "N"
<- "D"
<- "I"
<- "F"
<- " "
<- "="
<- "\""
<- ","
<- " "
<- "E"
<- "N"
<- "D"
<- "I"
<- "F"
<- "\r\n"
<- "ENDIF ="
<- " "
<- "\r\n"
<- "\"ENDIF\" is not defined or not active"
<- "\r\n"
<- "(dbx) "
-> "print \"THEN =\", THEN\n"
<- "p"
<- "r"
<- "i"
<- "n"
<- "t"
<- " "
<- "\""
<- "T"
<- "H"
<- "E"
<- "N"
<- " "
<- "="
<- "\""
<- ","
<- " "
<- "T"
<- "H"
<- "E"
<- "N"
<- "\r\n"
<- "THEN ="
<- " "
<- "\r\n"
<- "\"THEN\" is not defined or not active"
<- "\r\n"
<- "(dbx) "
-> "print \"TIMEEX =\", TIMEEX\n"
<- "print \"TIMEEX =\", TIMEEX\r\n"
<- "TIMEEX = 0.001635 \r\n"
<- "(dbx) "
-> "print \"TIMEEN =\", TIMEEN\n"
<- "print \"T"
<- "I"
<- "M"
<- "E"
<- "E"
<- "N"
<- " "
<- "="
<- "\""
<- ","
<- " "
<- "T"
<- "I"
<- "M"
<- "E"
<- "E"
<- "N"
<- "\r\n"
<- "TIMEEN ="
<- " "
<- "0.000000"
<- " \r\n"
<- "(dbx) "
-> "print \"TEMPEX =\", TEMPEX\n"
<- "print "
<- "\""
<- "T"
<- "E"
<- "M"
<- "P"
<- "E"
<- "X"
<- " "
<- "="
<- "\""
<- ","
<- " "
<- "T"
<- "E"
<- "M"
<- "P"
<- "E"
<- "X"
<- "\r\n"
<- "TEMPEX ="
<- " "
<- "273.000000"
<- " \r\n"
<- "(dbx) "
-> "print \"PMASEN =\", PMASEN\n"
<- "p"
<- "r"
<- "i"
<- "n"
<- "t"
<- " "
<- "\""
<- "P"
<- "M"
<- "A"
<- "S"
<- "E"
<- "N"
<- " "
<- "="
<- "\""
<- ","
<- " "
<- "P"
<- "M"
<- "A"
<- "S"
<- "E"
<- "N"
<- "\r\n"
<- "PMASEN ="
<- " "
<- "1.000000"
<- " \r\n"
<- "(dbx) "
-> "print \"PMASEX =\", PMASEX\n"
<- "print \"PMASEX =\", PMASEX\r\n"
<- "PMASEX = 0.999999 \r\n"
<- "(dbx) "
-> "print \"FLOWP =\", FLOWP\n"
<- "print"
<- " "
<- "\""
<- "F"
<- "L"
<- "O"
<- "W"
<- "P"
<- " "
<- "="
<- "\""
<- ","
<- " "
<- "F"
<- "L"
<- "O"
<- "W"
<- "P"
<- "\r\n"
<- "FLOWP ="
<- " "
<- "0.000002"
<- " \r\n"
<- "(dbx) "
-> "print \"LBLSIZ =\", LBLSIZ\n"
<- "print \"LBLSIZ =\", LBLSIZ\r\n"
<- "LBLSIZ ="
<- " "
<- "\r\n"
<- "\"LBLSIZ\" is not defined or not active\r\n"
<- "(dbx) "
-> "print \"NTEMPC =\", NTEMPC\n"
<- "print "
<- "\""
<- "N"
<- "T"
<- "E"
<- "M"
<- "P"
<- "C"
<- " "
<- "="
<- "\""
<- ","
<- " "
<- "N"
<- "T"
<- "E"
<- "M"
<- "P"
<- "C"
<- "\r\n"
<- "NTEMPC ="
<- " "
<- "\r\n"
<- "\"NTEMPC\" is not defined or not active"
<- "\r\n"
<- "(dbx) "
-> "print \"$ =\", $\n"
<- "print"
<- " "
<- "\""
<- "$"
<- " "
<- "="
<- "\""
<- ","
<- " "
<- "$"
<- "\r\n"
<- "$ ="
<- " "
<- "\r\n"
<- "\"$\" is not defined or not active"
<- "\r\n"
<- "(dbx) "
-> "print \"LAW =\", LAW\n"
<- "print \"L"
<- "A"
<- "W"
<- " "
<- "="
<- "\""
<- ","
<- " "
<- "L"
<- "A"
<- "W"
<- "\r\n"
<- "LAW ="
<- " "
<- "7"
<- " \r\n"
<- "(dbx) "
-> "print \"SITMAX =\", SITMAX\n"
<- "print \"SITMAX =\", SITMAX\r\n"
<- "SITMAX ="
<- " \r\n"
<- "\"SITMAX\" is not defined or not active\r\n"
<- "(dbx) "
-> "print \"NZONES =\", NZONES\n"
<- "print \"NZONES =\", NZONES\r\n"
<- "NZONES ="
<- " "
<- "\r\n"
<- "\"NZONES\" is not defined or not active\r\n"
<- "(dbx) "
-> "print \"NPSETS =\", NPSETS\n"
<- "print \""
<- "N"
<- "P"
<- "S"
<- "E"
<- "T"
<- "S"
<- " "
<- "="
<- "\""
<- ","
<- " "
<- "N"
<- "P"
<- "S"
<- "E"
<- "T"
<- "S"
<- "\r\n"
<- "NPSETS ="
<- " "
<- "\r\n"
<- "\"NPSETS\" is not defined or not active\r\n"
<- "(dbx) "
-> "quit\n"
<- "quit\r\n"
#  Running DBX (pid 23224, tty /dev/ttyp5)...Exit 0.
#  Saving history in "/users/jos/.ddd/history"...
#  Saving history in "/users/jos/.ddd/history"...done.
#  Thanks for using DDD 3.0!
