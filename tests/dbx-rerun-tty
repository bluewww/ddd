From zs@sgi.com  Wed Dec  2 14:32:52 1998
From: Zdenek Sekera <zs@sgi.com>
Subject: Re: [ddd-bugs] ddd 11-25, run/rerun has problems
To: Andreas Zeller <zeller@gnu.org>
Date: Wed, 02 Dec 1998 14:27:23 +0100
Organization: Silicon Graphics
Received: from eugate.sgi.com (eugate.sgi.com [193.73.159.10])
	by infbssys.ips.cs.tu-bs.de (8.9.1/8.9.1) with ESMTP id OAA15312
	for <zeller@gnu.org>; Wed, 2 Dec 1998 14:29:43 +0100
Received: from sgls.gland.sgi.com (sgls.gland.sgi.com [144.253.147.2]) by eugate.sgi.com (980305.SGI.8.8.8-aspam-6.2/980304.SGI-aspam-europe) via SMTP id OAA00636
	for <@eugate.sgi.com:zeller@gnu.org>; Wed, 2 Dec 1998 14:29:24 +0100 (MET)
	mail_from (zs@sgi.com)
Received: from strad.gland.sgi.com by sgls.gland.sgi.com via ESMTP (950413.SGI.8.6.12/930416.SGI)
	for <@sgls.gland.sgi.com:zeller@gnu.org> id OAA10043; Wed, 2 Dec 1998 14:27:27 +0100
Received: from sgi.com by strad.gland.sgi.com via ESMTP (980427.SGI.8.8.8/930416.SGI)
	for <zeller@gnu.org> id OAA83891; Wed, 2 Dec 1998 14:27:23 +0100 (MET)
Sender: zs@sgi.com
Message-ID: <3665403B.8C6A5D5E@sgi.com>
X-Mailer: Mozilla 4.07C-SGI [en] (X11; I; IRIX 6.5 IP22)
MIME-Version: 1.0
References: <365D64F3.8B0302C5@sgi.com> <ogbtlrevpu.fsf@infbssts.ips.cs.tu-bs.de>
Content-Type: multipart/mixed; boundary="------------D0A4E813654E26B4571072D1"

This is a multi-part message in MIME format.
--------------D0A4E813654E26B4571072D1
Content-Type: text/plain; charset=us-ascii
Content-Transfer-Encoding: 7bit

Andreas Zeller wrote:
> 
> Hi!
> 
> Zdenek Sekera <zs@sgi.com> writes:
> 
> > Select running parameters from program->run.
> > Run the program in the ddd console (not the execution window).
> > When doen, click on 'run' on command tools, it will correctly
> > rerun the job with previous parameters (that fixes a bug in 3.0
> > version).
> >
> > However, the same sequence will _not_ work when executing in  the
> > execution window. 'run' will forget the choice and rerun with
> > default (blank) parameters.
> 
> I need a `~/.ddd/log' file that illustrates this behaviour.
> 

Sorry to be so late with my answer but I got caught in some urgent work.
Attached you'll find two files: log.console and log.exec that are
.ddd/log
file from respectively running in the ddd console window and in the
execution window. My complaint is clearly seen there. I've put some
comments inside both file for you, they always start with '<--ZS'.
The executions in both windows were absolutely identical as far as
clicking is concerned.

Hope this helps.

---Zdenek
--------------D0A4E813654E26B4571072D1
Content-Type: text/plain; charset=us-ascii; name="log.console"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline; filename="log.console"

This is the output when running in the ddd console.
==================================================





DDD 1998-11-25 (mips-sgi-irix6.5), Copyright (C) 1998 TU Braunschweig.
Compiled with CC
Requires X11R6, Xt11R6, Motif 1.2.4 (OSF/Motif Version 1.2.4)
Includes DDD core, manual, app-defaults, XPM 3.4.6, Athena Panner
Built 1998-11-26 by Zdenek Sekera <zs@cray.com>.
$  ddd
+  /bin/sh -c 'exec dbx'
#  Hello, world!
#  Starting DBX...
#  Running DBX (pid 74282, tty /dev/ttyq5)...
#  Current language: c/c++
<- "dbx version 7.2.1.2m patch3441 Oct 20 1998 14:00:38\n"
<- "(dbx) "
-> "sh stty -echo -onlcr\n"
<- "(dbx) "
-> "set $page = 1\n"
<- "(dbx) "
-> "frame\n"
<- "\n"
<- "\"frame\" is not a valid command name.\n"
<- "error: frame\n"
<- "            ^ Apparent syntax error in examine command. expected / ?\n"
<- "(dbx) "
-> "func\n"
<- "\n"
<- "no active process\n"
<- "(dbx) "
-> "dbxenv run_io\n"
<- "\n"
<- "\"dbxenv\" is not a valid command name.\n"
<- "error: dbxenv run_io\n"
<- "              ^ Apparent syntax error in examine command. expected / ?\n"
<- "(dbx) "
-> "print -r 4711\n"
<- "\n"
<- "Found  4711\n"
<- "error: print -r 4711\n"
<- "                ^ Expected end of print statement\n"
<- "(dbx) "
-> "where -h\n"
<- "error: where -h\n"
<- "             ^ syntax error: Unparseable characters after command!\n"
<- "(dbx) "
-> "display\n"
<- "\n"
<- "\"display\" is not a valid command name.\n"
<- "error: display\n"
<- "              ^ Apparent syntax error in examine command. expected / ?\n"
<- "(dbx) "
-> "clear\n"
<- "\n"
<- "\"clear\" is not a valid command name.\n"
<- "error: clear\n"
<- "            ^ Apparent syntax error in examine command. expected / ?\n"
<- "(dbx) "
-> "help handler\n"
<- "Invalid keyword handler\n"
<- "(dbx) "
-> "pwd\n"
<- "\n"
<- "\"pwd\" is not a valid command name.\n"
<- "error: pwd\n"
<- "          ^ Apparent syntax error in examine command. expected / ?\n"
<- "(dbx) "
-> "help setenv\n"
<- "These are for modifying/seeing the environment variable list in dbx.\n"
<- "They take effect on the givenfile when the victim program is\n"
<- "run or rerun.     This way one can have a set of environment\n"
<- "variable in effect in the program being debugged without changing\n"
<- "the environment in the shell used to start dbx.\n"
<- "These commands have no effect whatever on the shell which was used\n"
<- "to start dbx.\n"
<- "\n"
<- "The general approach is like that in csh(1), as is the output format.\n"
<- "\n"
<- "printenv                       - print environment variable list.\n"
<- "unsetenv   x                   - remove x from the environment\n"
<- "setenv                         - like printenv\n"
<- "setenv     x                   - set x to an empty value\n"
<- "setenv     x y                 - set x to y  (y not a dbx variable)\n"
<- "setenv     x $y                - set x to be the value of the dbx variable $y\n"
<- "setenv     x \"anything at all\" - set x to be the string. The quotes are \n"
<- "                                 stripped off.\n"
<- "\n"
<- "If environment variables variables PAGER or EDITOR are changed the effect\n"
<- "on the running dbx is undefined (in other words, the new values may\n"
<- "More (n if no)?"
-> "\n"
<- "or may not affect the running dbx).\n"
<- "(dbx) "
-> "help edit\n"
<- "edit                           - invoke editor on current file\n"
<- "edit <file>                    - invoke editor on file\n"
<- "edit <func>                    - invoke editor on file <func> is in\n"
<- " \n"
<- " There is a minor limitation on <func> since the command parsing uses\n"
<- " shell-like parsing.  multi-part names using back-quotes around the\n"
<- " first part of the name (example:  \'a.b`.foo ) will not work correctly\n"
<- " to access function foo in module  `a.b` (with a Fortran\n"
<- " source file a.b.f for example).\n"
<- "\n"
<- "(dbx) "
-> "help make\n"
<- "Invalid keyword make\n"
<- "(dbx) "
-> "help regs\n"
<- "Invalid keyword regs\n"
<- "(dbx) "
-> "print \"DDD\"\n"
<- "DDD \n"
<- "(dbx) "
-> "help when\n"
<- "\'when\' is just like `stop\'  except that instead of  stopping when the\n"
<- "conditions are met, the command_list (semicolon-separated dbx commands )\n"
<- "is executed.  If one of the commands in the list is `stop\' (with no operands)\n"
<- "then the process will stop when the command_list is executed.\n"
<- "\n"
<- "when if <exp> {command_list} -\n"
<- "                          execute command_list on every line executed for which\n"
<- "                          <exp> is true.\n"
<- "when  at <line> [if <exp>] {command_list} -\n"
<- "                          execute the specified command list when the\n"
<- "                          conditions are met at line <line>.\n"
<- "when in <proc> [if <exp>] {command_list}  -\n"
<- "                          execute the specified command list when the\n"
<- "                          conditions are met in procedure <proc>.\n"
<- "when <var> [at <line>] [if <exp>] {command_list} -\n"
<- "                          execute the specified command list when the\n"
<- "                          conditions are met.\n"
<- "when <var> [in procedure] [if <exp>] {command_list} -\n"
<- "                          execute the specified command list when the\n"
<- "                          conditions are met.\n"
<- "(dbx) "
-> "delete 4711 4711\n"
<- "\n"
<- "Found  4711\n"
<- "error: delete 4711 4711\n"
<- "                   ^ Expected end of delete statement\n"
<- "(dbx) "
-> "help run\n"
<- "run   arg1 arg2 ...            - begin execution of the program\n"
<- "rerun arg1 arg2 ...            - begin execution of the program\n"
<- "rerun                          - restart execution of the program\n"
<- "                                 with same arguments last used on run or rerun\n"
<- "\n"
<- "The run and rerun commands use the command interpreter indicated by the\n"
<- "environment variable SHELL to expand and interpret\n"
<- "the arguments and redirections.  dbx has built in knowledge of the\n"
<- "Bourne shell (sh) the C shell (csh) and the Korn shell (ksh).  If a user is\n"
<- "using a different shell, the run command will not be able to disable invocation\n"
<- "of the shell\'s initialization file (.cshrc, .kshrc, etc.)  This may cause the\n"
<- "run command to fail if the user\'s initialization file spawns off a program or a\n"
<- "sub shell.  If a non standard shell is used, the dbx variable $shellparameters\n"
<- "may be set to a string that will instruct the shell to skip loading of the\n"
<- "initialization file (for csh one would use \"-f\", for example.)  See the\n"
<- "description of $shellparameters in the $variables section for more information.\n"
<- "To verify exactly how your application is being started by the\n"
<- "run/rerun command, start dbx with the -d option (there is no way\n"
<- "to check how your application is started except by adding -d on\n"
<- "the command line, for example:  \"dbx -d a.out\".\n"
<- "This will show other data which you should ignore, but run might show, for\n"
<- "example, with /bin/csh as the SHELL:\n"
<- "More (n if no)?"
-> "\n"
<- "(gnome) r\n"
<- "Now execute givenfile with the following call:\n"
<- "execvp(\"/bin/csh\", \n"
<- "        \"/bin/csh,\n"
<- "        \"-f,\n"
<- "        \"-c,\n"
<- "        \"exec ./a.out,\n"
<- "        (char *)0);\n"
<- "Process 21473 (a.out) started\n"
<- "\n"
<- "If one wishes to debug a program with file-descriptors other than\n"
<- "the default 0,1,2 open, then care is required, since if $SHELL is\n"
<- "set to a C-shell, the extra file descriptors will be closed by\n"
<- "csh(1).  Instead, setenv SHELL /bin/sh (which means one can only use\n"
<- "sh-style redirections) for example, as sh(1) does not close the\n"
<- "extra file-descriptors.\n"
<- "\n"
<- "(dbx) "
-> "help givenfile\n"
<- "givenfile                      - displays the name of the program being dbx\'d\n"
<- "givenfile <name>               - sets program to debug, like \'dbx name\'.\n"
<- "                                 Kills the current running processes and\n"
<- "                                 reads in <name>\'s symbol table.\n"
<- "corefile                       - displays the name of the core file. Says\n"
<- "                                 if the corefile is currently used by dbx\n"
<- "                                 to display program data.\n"
<- "corefile   <core>              - identifies corefile name, like\n"
<- "                                 \'dbx name core\'. Makes dbx use that core file\n"
<- "                                 for program data\n"
<- "(dbx) "
-> "help cont\n"
<- "cont                           - continue execution and wait until event\n"
<- "                                 see $promptonfork $mp_program and\n"
<- "                                 MULTIPLE PROCESS DEBUGGING for the\n"
<- "                                 behavior of this command with fork/exec/sproc\n"
<- "                                 If the program has a signal handler for\n"
<- "                                 a signal and the program stopped last on\n"
<- "                                 that signal, this passes the signal to\n"
<- "                                 the process on continuing.\n"
<- "cont <signal>                  - continue with signal and wait until event\n"
<- "                                 You must use the signal number or name\n"
<- "                                 unless the last stop for this process was\n"
<- "                                 via the desired signal.  Since it is difficult\n"
<- "                                 to be sure of this, it is simplest to\n"
<- "                                 use the <signal> clause.\n"
<- "cont at <line>                 - continue until <line> is reached\n"
<- "                                  (temporary breakpoint)\n"
<- "cont to <line>                 - same as \'continue at <line>\'\n"
<- "cont in <proc>                 - continue until <proc> is reached  (see above)\n"
<- "cont <signal> at <line>        - continue with signal until <line> (see above)\n"
<- "cont <signal> to <line>        - same as \'cont <signal> at <line>\'\n"
<- "cont <signal> in <proc>        - continue with signal until <proc> (see above)\n"
<- "(dbx) "
-> "help examine\n"
<- "<exp>/<count><format>          - display <count> formatted memory items, in\n"
<- "                                 increasing address (see ASSEMBLY DEBUGGING\n"
<- "                                 below)(examine memory)\n"
<- "<exp>?<count><format>          - display <count> formatted memory items, in\n"
<- "                                 decreasing address (see ASSEMBLY DEBUGGING\n"
<- "                                 below)(examine memory)\n"
<- "\n"
<- "For additional options and the format letters, try\n"
<- "        help examineformat\n"
<- "(dbx) "
-> "help rerun\n"
<- "run   arg1 arg2 ...            - begin execution of the program\n"
<- "rerun arg1 arg2 ...            - begin execution of the program\n"
<- "rerun                          - restart execution of the program\n"
<- "                                 with same arguments last used on run or rerun\n"
<- "\n"
<- "The run and rerun commands use the command interpreter indicated by the\n"
<- "environment variable SHELL to expand and interpret\n"
<- "the arguments and redirections.  dbx has built in knowledge of the\n"
<- "Bourne shell (sh) the C shell (csh) and the Korn shell (ksh).  If a user is\n"
<- "using a different shell, the run command will not be able to disable invocation\n"
<- "of the shell\'s initialization file (.cshrc, .kshrc, etc.)  This may cause the\n"
<- "run command to fail if the user\'s initialization file spawns off a program or a\n"
<- "sub shell.  If a non standard shell is used, the dbx variable $shellparameters\n"
<- "may be set to a string that will instruct the shell to skip loading of the\n"
<- "initialization file (for csh one would use \"-f\", for example.)  See the\n"
<- "description of $shellparameters in the $variables section for more information.\n"
<- "To verify exactly how your application is being started by the\n"
<- "run/rerun command, start dbx with the -d option (there is no way\n"
<- "to check how your application is started except by adding -d on\n"
<- "the command line, for example:  \"dbx -d a.out\".\n"
<- "This will show other data which you should ignore, but run might show, for\n"
<- "example, with /bin/csh as the SHELL:\n"
<- "More (n if no)?"
-> "\n"
<- "(gnome) r\n"
<- "Now execute givenfile with the following call:\n"
<- "execvp(\"/bin/csh\", \n"
<- "        \"/bin/csh,\n"
<- "        \"-f,\n"
<- "        \"-c,\n"
<- "        \"exec ./a.out,\n"
<- "        (char *)0);\n"
<- "Process 21473 (a.out) started\n"
<- "\n"
<- "If one wishes to debug a program with file-descriptors other than\n"
<- "the default 0,1,2 open, then care is required, since if $SHELL is\n"
<- "set to a C-shell, the extra file descriptors will be closed by\n"
<- "csh(1).  Instead, setenv SHELL /bin/sh (which means one can only use\n"
<- "sh-style redirections) for example, as sh(1) does not close the\n"
<- "extra file-descriptors.\n"
<- "\n"
<- "(dbx) "
-> "language\n"
<- "\n"
<- "\"language\" is not a valid command name.\n"
<- "error: language\n"
<- "               ^ Apparent syntax error in examine command. expected / ?\n"
<- "(dbx) "
-> "sh pwd\n"
<- "/build/zs/irix6.5m/work/irix/cmd/icrash\n"
<- "(dbx) "
-> "file\n"
<- "no current file\n"
<- "(dbx) "
-> "list\n"
<- "no current file\n"
<- "(dbx) "
-> "status\n"
<- "(dbx) "
-> "givenfile \n"
<- "No current givenfile\n"
<- "(dbx) "
-> "set $assignverify = 1\n"
<- "(dbx) "
-> "set $ctypenames = 1\n"
<- "(dbx) "
-> "set $fp_precise = 0\n"
<- "(dbx) "
-> "set $framereg = 1\n"
<- "(dbx) "
-> "set $groupforktoo = 0\n"
<- "(dbx) "
-> "set $hexchars = 0\n"
<- "(dbx) "
-> "set $hexdoubles = 0\n"
<- "(dbx) "
-> "set $hexin = 0\n"
<- "(dbx) "
-> "set $hexints = 1\n"
<- "(dbx) "
-> "set $hexstrings = 0\n"
<- "(dbx) "
-> "set $mp_program = 1\n"
<- "(dbx) "
-> "set $nonstop = 0\n"
<- "(dbx) "
-> "set $octin = 0\n"
<- "(dbx) "
-> "set $octints = 1\n"
<- "(dbx) "
-> "set $page = 1\n"
<- "(dbx) "
-> "set $pendingtraps = 0\n"
<- "(dbx) "
-> "set $piaddtohist = 1\n"
<- "(dbx) "
-> "set $pimode = 0\n"
<- "(dbx) "
-> "set $print_exception_frame = 0\n"
<- "(dbx) "
-> "set $printdata = 0\n"
<- "(dbx) "
-> "set $printwhilestep = 0\n"
<- "(dbx) "
-> "set $printwide = 0\n"
<- "(dbx) "
-> "set $regstyle = 1\n"
<- "(dbx) "
-> "set $repeatmode = 0\n"
<- "(dbx) "
-> "set $rimode = 0\n"
<- "(dbx) "
-> "set $searchstatics = 1\n"
<- "(dbx) "
-> "set $stdc = 0\n"
<- "(dbx) "
-> "set $stopformat = 0\n"
<- "(dbx) "
-> "set $addrfmt = \"0x%x\"\n"
<- "(dbx) "
-> "set $addrfmt64 = \"0x%llx\"\n"
<- "(dbx) "
-> "set $casesense = 2\n"
<- "(dbx) "
-> "set $editor = \"vim\"\n"
<- "(dbx) "
-> "set $lastchild = 0\n"
<- "(dbx) "
-> "set $lines = 20\n"
<- "(dbx) "
-> "set $listwindow = 10\n"
<- "(dbx) "
-> "set $maxstrlen = 128\n"
<- "(dbx) "
-> "set $pager = \"more\"\n"
<- "(dbx) "
-> "set $pagewidth = 80\n"
<- "(dbx) "
-> "set $pagewindow = 22\n"
<- "(dbx) "
-> "set $prompt = \"(dbx) \"\n"
<- "(dbx) "
-> "set $promptonfork = 0\n"
<- "(dbx) "
-> "set $shellparameters = \"\"\n"
<- "(dbx) "
-> "set $showbreakaddrs = 0\n"
<- "(dbx) "
-> "set $showfilename = 0\n"
<- "(dbx) "
-> "set $sourcepathrule = 0\n"
<- "(dbx) "
-> "set $stacktracelimit = 100\n"
<- "(dbx) "
-> "set $stepintoall = 0\n"
<- "(dbx) "
-> "set $tagfile = \"tags\"\n"
<- "(dbx) "
-> "set $whereisdsolimit = 1\n"
<- "(dbx) "
-> "# reset\n"
<- "\n"
<- "Syntax error: unrecognized command #\n"
<- "(dbx) "
-> "file\n"
<- "no current file\n"
<- "(dbx) "
-> "list\n"
<- "no current file\n"
<- "(dbx) "
-> "status\n"
<- "(dbx) "
-> "givenfile \n"
<- "No current givenfile\n"
<- "(dbx) "
#  Starting DBX...done.
#  Welcome to DDD 1998-11-25 "Nightsleeper" (mips-sgi-irix6.5)
-> "help detach\n"
<- "Invalid keyword detach\n"
<- "(dbx) "
-> "help run\n"
<- "run   arg1 arg2 ...            - begin execution of the program\n"
<- "rerun arg1 arg2 ...            - begin execution of the program\n"
<- "rerun                          - restart execution of the program\n"
<- "                                 with same arguments last used on run or rerun\n"
<- "\n"
<- "The run and rerun commands use the command interpreter indicated by the\n"
<- "environment variable SHELL to expand and interpret\n"
<- "the arguments and redirections.  dbx has built in knowledge of the\n"
<- "Bourne shell (sh) the C shell (csh) and the Korn shell (ksh).  If a user is\n"
<- "using a different shell, the run command will not be able to disable invocation\n"
<- "of the shell\'s initialization file (.cshrc, .kshrc, etc.)  This may cause the\n"
<- "run command to fail if the user\'s initialization file spawns off a program or a\n"
<- "sub shell.  If a non standard shell is used, the dbx variable $shellparameters\n"
<- "may be set to a string that will instruct the shell to skip loading of the\n"
<- "initialization file (for csh one would use \"-f\", for example.)  See the\n"
<- "description of $shellparameters in the $variables section for more information.\n"
<- "To verify exactly how your application is being started by the\n"
<- "run/rerun command, start dbx with the -d option (there is no way\n"
<- "to check how your application is started except by adding -d on\n"
<- "the command line, for example:  \"dbx -d a.out\".\n"
<- "This will show other data which you should ignore, but run might show, for\n"
<- "example, with /bin/csh as the SHELL:\n"
<- "More (n if no)?"
-> "\n"
<- "(gnome) r\n"
<- "Now execute givenfile with the following call:\n"
<- "execvp(\"/bin/csh\", \n"
<- "        \"/bin/csh,\n"
<- "        \"-f,\n"
<- "        \"-c,\n"
<- "        \"exec ./a.out,\n"
<- "        (char *)0);\n"
<- "Process 21473 (a.out) started\n"
<- "\n"
<- "If one wishes to debug a program with file-descriptors other than\n"
<- "the default 0,1,2 open, then care is required, since if $SHELL is\n"
<- "set to a C-shell, the extra file descriptors will be closed by\n"
<- "csh(1).  Instead, setenv SHELL /bin/sh (which means one can only use\n"
<- "sh-style redirections) for example, as sh(1) does not close the\n"
<- "extra file-descriptors.\n"
<- "\n"
<- "(dbx) "
-> "help step\n"
<- "step                           - single step 1 time.\n"
<- "step <int>                     - single step <int> times.\n"
<- "                                 \'step\' steps over procedures compiled without\n"
<- "                                 symbols by default.\n"
<- "                                 Breakpoints in procedures stepped over\n"
<- "                                 are honored.\n"
<- "                                 Functions coded entirely on one line cause\n"
<- "                                 step to act like stepi, since the actual\n"
<- "                                 code is all assigned one source line.\n"
<- "                                 Outstanding signals are ignored.\n"
<- "\n"
<- "  A step into a dso will fail (will result effectively in a \'next\')\n"
<- "  if rld(1) has not yet lazily evaluated the address of the function.\n"
<- "  Before rerunning the application, setenv LD_BIND_NOW 1\n"
<- "  will force rld to do immediate address resolution and will avoid\n"
<- "  the problem. \n"
<- "\n"
<- "(dbx) "
-> "help stepi\n"
<- "stepi                          - single step 1 assembly instruction\n"
<- "stepi <exp>                    - single step <exp> assembly instructions.\n"
<- "                                 See  $printwhilestep\n"
<- "\n"
<- "   A stepi into a dso will get into strange territory\n"
<- "   (rld(1) specifically)  and stack traces will not work\n"
<- "   well if rld(1) has not yet lazily evaluated the address\n"
<- "   of the function.  Before rerunning the application,\n"
<- "   setenv LD_BIND_NOW 1 will force rld to do immediate\n"
<- "   address resolution and will avoid the problem.\n"
<- "\n"
<- "nexti                          - like stepi, but step over subroutine calls\n"
<- "nexti <exp>                    - like stepi <exp>, but step over\n"
<- "                                 subroutine calls\n"
<- "$printwhilestep - if != 0, acts as if \'step[i] n\' was \'step[i]\' n times\n"
<- "(dbx) "
-> "help next\n"
<- "next                           - single step 1 time.      steps over procedures\n"
<- "next <int>                     - single step <int> times. steps over procedures\n"
<- "                                 \'next\' honors breakpoints in procedures\n"
<- "                                 stepped over.\n"
<- "                                 A consequence of this is that\n"
<- "                                 a ``stop if\'\' condition which is true will\n"
<- "                                 continue to be true -- making dbx stop after\n"
<- "                                 every statement in procedures one wanted to\n"
<- "                                 step over. Delete the ``stop if\'\'\n"
<- "                                 which has already become true to avoid the\n"
<- "                                 stops.\n"
<- "                                 Outstanding signals are ignored.\n"
<- "\n"
<- "(dbx) "
-> "help nexti\n"
<- "stepi                          - single step 1 assembly instruction\n"
<- "stepi <exp>                    - single step <exp> assembly instructions.\n"
<- "                                 See  $printwhilestep\n"
<- "\n"
<- "   A stepi into a dso will get into strange territory\n"
<- "   (rld(1) specifically)  and stack traces will not work\n"
<- "   well if rld(1) has not yet lazily evaluated the address\n"
<- "   of the function.  Before rerunning the application,\n"
<- "   setenv LD_BIND_NOW 1 will force rld to do immediate\n"
<- "   address resolution and will avoid the problem.\n"
<- "\n"
<- "nexti                          - like stepi, but step over subroutine calls\n"
<- "nexti <exp>                    - like stepi <exp>, but step over\n"
<- "                                 subroutine calls\n"
<- "$printwhilestep - if != 0, acts as if \'step[i] n\' was \'step[i]\' n times\n"
<- "(dbx) "
-> "help until\n"
<- "Invalid keyword until\n"
<- "(dbx) "
-> "help cont\n"
<- "cont                           - continue execution and wait until event\n"
<- "                                 see $promptonfork $mp_program and\n"
<- "                                 MULTIPLE PROCESS DEBUGGING for the\n"
<- "                                 behavior of this command with fork/exec/sproc\n"
<- "                                 If the program has a signal handler for\n"
<- "                                 a signal and the program stopped last on\n"
<- "                                 that signal, this passes the signal to\n"
<- "                                 the process on continuing.\n"
<- "cont <signal>                  - continue with signal and wait until event\n"
<- "                                 You must use the signal number or name\n"
<- "                                 unless the last stop for this process was\n"
<- "                                 via the desired signal.  Since it is difficult\n"
<- "                                 to be sure of this, it is simplest to\n"
<- "                                 use the <signal> clause.\n"
<- "cont at <line>                 - continue until <line> is reached\n"
<- "                                  (temporary breakpoint)\n"
<- "cont to <line>                 - same as \'continue at <line>\'\n"
<- "cont in <proc>                 - continue until <proc> is reached  (see above)\n"
<- "cont <signal> at <line>        - continue with signal until <line> (see above)\n"
<- "cont <signal> to <line>        - same as \'cont <signal> at <line>\'\n"
<- "cont <signal> in <proc>        - continue with signal until <proc> (see above)\n"
<- "More (n if no)?"
-> "\n"
<- "(dbx) "
-> "help signal\n"
<- "Invalid keyword signal\n"
<- "(dbx) "
-> "help kill\n"
<- "kill                           - kill active process\n"
<- "kill <pid> ...                 - kill process (list) specified\n"
<- "(dbx) "
-> "help up\n"
<- "up                             - move up one activation level in the stack\n"
<- "up <exp>                       - move up <exp> activation levels in the stack\n"
<- "down                           - move down one activation level in stack\n"
<- "down <exp>                     - move down <exp> activation levels in stack\n"
<- "(dbx) "
-> "help down\n"
<- "up                             - move up one activation level in the stack\n"
<- "up <exp>                       - move up <exp> activation levels in the stack\n"
<- "down                           - move down one activation level in stack\n"
<- "down <exp>                     - move down <exp> activation levels in stack\n"
<- "(dbx) "
#  Filtering files...
#  Filtering files...done.
-> "givenfile /build/zs/irix6.5m/work/irix/cmd/icrash/icrash\n"
<- "Executable /build/zs/irix6.5m/work/irix/cmd/icrash/icrash\n"
<- "(dbx) "
-> "file\n"
<- "/build/zs/irix6.5m/work/irix/cmd/icrash/main.c\n"
<- "(dbx) "
-> "list\n"
<- ">"
<- "*"
<- "  80  "
<- "{"
<- "\n"
<- " "
<- " "
<- "  81  "
<- "\tFILE *ofp;"
<- "\n"
<- " "
<- " "
<- "  82  "
<- "\tint i, c, errflg = 0;\n"
<- "    83  \tcommand_t cb;\n"
<- "    84  \n"
<- "    85  \t/* getopt() variables.\n"
<- "    86  \t */\n"
<- "    87  \textern char *optarg;\n"
<- "    88  \textern int optind;\n"
<- "    89  \textern int opterr;\n"
<- "(dbx) "
-> "status\n"
<- "(dbx) "
#  Reading file "/build/zs/irix6.5m/work/irix/cmd/icrash/main.c"...
#  Reading file "/build/zs/irix6.5m/work/irix/cmd/icrash/main.c"...done.
#  File "/build/zs/irix6.5m/work/irix/cmd/icrash/main.c" 562 lines, 26460 characters
-> "givenfile \n"
<- "Current givenfile is /build/zs/irix6.5m/work/irix/cmd/icrash/icrash\n"
<- "(dbx) "
-> "print variables\n"
<- "Appropriate symbol not found for: variables\n"
<- "<symbol not found>"
<- " "
<- "\n"
<- "(dbx) "
-> "print mem\n"
<- "Appropriate symbol not found for: mem\n"
<- "<symbol not found> \n"
<- "(dbx) "
-> "print to\n"
<- "error: print to\n"
<- "             ^ syntax error\n"
<- "\n"
<- "Suggestion: to is a dbx keyword; a revised command is in history.\n"
<- "Type !104 or !! to execute: print (to)\n"
<- "(dbx) "
-> "print zero\n"
<- "0x0"
<- " "
<- "\n"
<- "(dbx) "
-> "print c\n"
<- "<no such address>"
<- " "
<- "\n"
<- "(dbx) "
-> "commands\n"
<- "\n"
<- "\"commands\" is not a valid command name.\n"
<- "error: "
<- "commands\n"
<- " "
<- " "
<- "             ^ Apparent syntax error in examine command. expected / ?\n"
<- "(dbx) "
-> "setenv TERM dumb\n"
<- "(dbx) "
-> "run -n 20\n"		<--ZS, my chosen parameters
				<--ZS, notice the output
				<-- it will be identical to rerun
<- "Process 74192 (icrash) started\n"
<- "corefile = vmcore.20.comp, namelist = unix.20, outfile = stdout\n"
<- "\n"
<- "Please wait....."
<- "corefile is version "
<- " 4"
<- "."
<- "."
<- "."
<- "\n"
<- ">> "
-> "quit\n"
<- "Process 74192 (icrash) terminated\n"
<- "(dbx) "
-> "file\n"
<- "no current file\n"
<- "(dbx) "
-> "status\n"
<- "(dbx) "
-> "setenv TERM dumb\n"
<- "(dbx) "
-> "rerun\n"			<--ZS, my params are still there,
				<-- the output below is identical
				<-- to the first run above
<- "Process 74286 (icrash) started\n"
<- "corefile = vmcore.20.comp, namelist = unix.20, outfile = stdout\n"
<- "\n"
<- "Please wait....."
<- "corefile is version  4."
<- "."
<- "."
<- "\n"
<- ">> "
-> "quit\n"
<- "Process 74286 (icrash) terminated\n"
<- "(dbx) "
-> "file\n"
<- "no current file\n"
<- "(dbx) "
-> "status\n"
<- "(dbx) "
-> "quit\n"
#  Running DBX (pid 74282, tty /dev/ttyq5)...Exit 0.
#  Saving history in "/usr/people/zs/.ddd/history"...
#  Saving history in "/usr/people/zs/.ddd/history"...done.
#  Thanks for using DDD 1998-11-25!

--------------D0A4E813654E26B4571072D1
Content-Type: text/plain; charset=us-ascii; name="log.exec"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline; filename="log.exec"

This is a log when executing in an execution window.
==================================================



DDD 1998-11-25 (mips-sgi-irix6.5), Copyright (C) 1998 TU Braunschweig.
Compiled with CC
Requires X11R6, Xt11R6, Motif 1.2.4 (OSF/Motif Version 1.2.4)
Includes DDD core, manual, app-defaults, XPM 3.4.6, Athena Panner
Built 1998-11-26 by Zdenek Sekera <zs@cray.com>.
$  ddd
+  /bin/sh -c 'exec dbx'
#  Hello, world!
#  Starting DBX...
#  Running DBX (pid 74129, tty /dev/ttyq5)...
#  Current language: c/c++
<- "dbx version 7.2.1.2m patch3441 Oct 20 1998 14:00:38\n"
<- "(dbx) "
-> "sh stty -echo -onlcr\n"
<- "(dbx) "
-> "set $page = 1\n"
<- "(dbx) "
-> "frame\n"
<- "\n"
<- "\"frame\" is not a valid command name.\n"
<- "error: frame\n"
<- "            ^ Apparent syntax error in examine command. expected / ?\n"
<- "(dbx) "
-> "func\n"
<- "\n"
<- "no active process\n"
<- "(dbx) "
-> "dbxenv run_io\n"
<- "\n"
<- "\"dbxenv\" is not a valid command name.\n"
<- "error: dbxenv run_io\n"
<- "              ^ Apparent syntax error in examine command. expected / ?\n"
<- "(dbx) "
-> "print -r 4711\n"
<- "\n"
<- "Found  4711\n"
<- "error: print -r 4711\n"
<- "                ^ Expected end of print statement\n"
<- "(dbx) "
-> "where -h\n"
<- "error: where -h\n"
<- "             ^ syntax error: Unparseable characters after command!\n"
<- "(dbx) "
-> "display\n"
<- "\n"
<- "\"display\" is not a valid command name.\n"
<- "error: display\n"
<- "              ^ Apparent syntax error in examine command. expected / ?\n"
<- "(dbx) "
-> "clear\n"
<- "\n"
<- "\"clear\" is not a valid command name.\n"
<- "error: clear\n"
<- "            ^ Apparent syntax error in examine command. expected / ?\n"
<- "(dbx) "
-> "help handler\n"
<- "Invalid keyword handler\n"
<- "(dbx) "
-> "pwd\n"
<- "\n"
<- "\"pwd\" is not a valid command name.\n"
<- "error: pwd\n"
<- "          ^ Apparent syntax error in examine command. expected / ?\n"
<- "(dbx) "
-> "help setenv\n"
<- "These are for modifying/seeing the environment variable list in dbx.\n"
<- "They take effect on the givenfile when the victim program is\n"
<- "run or rerun.     This way one can have a set of environment\n"
<- "variable in effect in the program being debugged without changing\n"
<- "the environment in the shell used to start dbx.\n"
<- "These commands have no effect whatever on the shell which was used\n"
<- "to start dbx.\n"
<- "\n"
<- "The general approach is like that in csh(1), as is the output format.\n"
<- "\n"
<- "printenv                       - print environment variable list.\n"
<- "unsetenv   x                   - remove x from the environment\n"
<- "setenv                         - like printenv\n"
<- "setenv     x                   - set x to an empty value\n"
<- "setenv     x y                 - set x to y  (y not a dbx variable)\n"
<- "setenv     x $y                - set x to be the value of the dbx variable $y\n"
<- "setenv     x \"anything at all\" - set x to be the string. The quotes are \n"
<- "                                 stripped off.\n"
<- "\n"
<- "If environment variables variables PAGER or EDITOR are changed the effect\n"
<- "on the running dbx is undefined (in other words, the new values may\n"
<- "More (n if no)?"
-> "\n"
<- "or may not affect the running dbx).\n"
<- "(dbx) "
-> "help edit\n"
<- "edit                           - invoke editor on current file\n"
<- "edit <file>                    - invoke editor on file\n"
<- "edit <func>                    - invoke editor on file <func> is in\n"
<- " \n"
<- " There is a minor limitation on <func> since the command parsing uses\n"
<- " shell-like parsing.  multi-part names using back-quotes around the\n"
<- " first part of the name (example:  \'a.b`.foo ) will not work correctly\n"
<- " to access function foo in module  `a.b` (with a Fortran\n"
<- " source file a.b.f for example).\n"
<- "\n"
<- "(dbx) "
-> "help make\n"
<- "Invalid keyword make\n"
<- "(dbx) "
-> "help regs\n"
<- "Invalid keyword regs\n"
<- "(dbx) "
-> "print \"DDD\"\n"
<- "DDD \n"
<- "(dbx) "
-> "help when\n"
<- "\'when\' is just like `stop\'  except that instead of  stopping when the\n"
<- "conditions are met, the command_list (semicolon-separated dbx commands )\n"
<- "is executed.  If one of the commands in the list is `stop\' (with no operands)\n"
<- "then the process will stop when the command_list is executed.\n"
<- "\n"
<- "when if <exp> {command_list} -\n"
<- "                          execute command_list on every line executed for which\n"
<- "                          <exp> is true.\n"
<- "when  at <line> [if <exp>] {command_list} -\n"
<- "                          execute the specified command list when the\n"
<- "                          conditions are met at line <line>.\n"
<- "when in <proc> [if <exp>] {command_list}  -\n"
<- "                          execute the specified command list when the\n"
<- "                          conditions are met in procedure <proc>.\n"
<- "when <var> [at <line>] [if <exp>] {command_list} -\n"
<- "                          execute the specified command list when the\n"
<- "                          conditions are met.\n"
<- "when <var> [in procedure] [if <exp>] {command_list} -\n"
<- "                          execute the specified command list when the\n"
<- "                          conditions are met.\n"
<- "(dbx) "
-> "delete 4711 4711\n"
<- "\n"
<- "Found  4711\n"
<- "error: delete 4711 4711\n"
<- "                   ^ Expected end of delete statement\n"
<- "(dbx) "
-> "help run\n"
<- "run   arg1 arg2 ...            - begin execution of the program\n"
<- "rerun arg1 arg2 ...            - begin execution of the program\n"
<- "rerun                          - restart execution of the program\n"
<- "                                 with same arguments last used on run or rerun\n"
<- "\n"
<- "The run and rerun commands use the command interpreter indicated by the\n"
<- "environment variable SHELL to expand and interpret\n"
<- "the arguments and redirections.  dbx has built in knowledge of the\n"
<- "Bourne shell (sh) the C shell (csh) and the Korn shell (ksh).  If a user is\n"
<- "using a different shell, the run command will not be able to disable invocation\n"
<- "of the shell\'s initialization file (.cshrc, .kshrc, etc.)  This may cause the\n"
<- "run command to fail if the user\'s initialization file spawns off a program or a\n"
<- "sub shell.  If a non standard shell is used, the dbx variable $shellparameters\n"
<- "may be set to a string that will instruct the shell to skip loading of the\n"
<- "initialization file (for csh one would use \"-f\", for example.)  See the\n"
<- "description of $shellparameters in the $variables section for more information.\n"
<- "To verify exactly how your application is being started by the\n"
<- "run/rerun command, start dbx with the -d option (there is no way\n"
<- "to check how your application is started except by adding -d on\n"
<- "the command line, for example:  \"dbx -d a.out\".\n"
<- "This will show other data which you should ignore, but run might show, for\n"
<- "example, with /bin/csh as the SHELL:\n"
<- "More (n if no)?"
-> "\n"
<- "(gnome) r\n"
<- "Now execute givenfile with the following call:\n"
<- "execvp(\"/bin/csh\", \n"
<- "        \"/bin/csh,\n"
<- "        \"-f,\n"
<- "        \"-c,\n"
<- "        \"exec ./a.out,\n"
<- "        (char *)0);\n"
<- "Process 21473 (a.out) started\n"
<- "\n"
<- "If one wishes to debug a program with file-descriptors other than\n"
<- "the default 0,1,2 open, then care is required, since if $SHELL is\n"
<- "set to a C-shell, the extra file descriptors will be closed by\n"
<- "csh(1).  Instead, setenv SHELL /bin/sh (which means one can only use\n"
<- "sh-style redirections) for example, as sh(1) does not close the\n"
<- "extra file-descriptors.\n"
<- "\n"
<- "(dbx) "
-> "help givenfile\n"
<- "givenfile                      - displays the name of the program being dbx\'d\n"
<- "givenfile <name>               - sets program to debug, like \'dbx name\'.\n"
<- "                                 Kills the current running processes and\n"
<- "                                 reads in <name>\'s symbol table.\n"
<- "corefile                       - displays the name of the core file. Says\n"
<- "                                 if the corefile is currently used by dbx\n"
<- "                                 to display program data.\n"
<- "corefile   <core>              - identifies corefile name, like\n"
<- "                                 \'dbx name core\'. Makes dbx use that core file\n"
<- "                                 for program data\n"
<- "(dbx) "
-> "help cont\n"
<- "cont                           - continue execution and wait until event\n"
<- "                                 see $promptonfork $mp_program and\n"
<- "                                 MULTIPLE PROCESS DEBUGGING for the\n"
<- "                                 behavior of this command with fork/exec/sproc\n"
<- "                                 If the program has a signal handler for\n"
<- "                                 a signal and the program stopped last on\n"
<- "                                 that signal, this passes the signal to\n"
<- "                                 the process on continuing.\n"
<- "cont <signal>                  - continue with signal and wait until event\n"
<- "                                 You must use the signal number or name\n"
<- "                                 unless the last stop for this process was\n"
<- "                                 via the desired signal.  Since it is difficult\n"
<- "                                 to be sure of this, it is simplest to\n"
<- "                                 use the <signal> clause.\n"
<- "cont at <line>                 - continue until <line> is reached\n"
<- "                                  (temporary breakpoint)\n"
<- "cont to <line>                 - same as \'continue at <line>\'\n"
<- "cont in <proc>                 - continue until <proc> is reached  (see above)\n"
<- "cont <signal> at <line>        - continue with signal until <line> (see above)\n"
<- "cont <signal> to <line>        - same as \'cont <signal> at <line>\'\n"
<- "cont <signal> in <proc>        - continue with signal until <proc> (see above)\n"
<- "(dbx) "
-> "help examine\n"
<- "<exp>/<count><format>          - display <count> formatted memory items, in\n"
<- "                                 increasing address (see ASSEMBLY DEBUGGING\n"
<- "                                 below)(examine memory)\n"
<- "<exp>?<count><format>          - display <count> formatted memory items, in\n"
<- "                                 decreasing address (see ASSEMBLY DEBUGGING\n"
<- "                                 below)(examine memory)\n"
<- "\n"
<- "For additional options and the format letters, try\n"
<- "        help examineformat\n"
<- "(dbx) "
-> "help rerun\n"
<- "run   arg1 arg2 ...            - begin execution of the program\n"
<- "rerun arg1 arg2 ...            - begin execution of the program\n"
<- "rerun                          - restart execution of the program\n"
<- "                                 with same arguments last used on run or rerun\n"
<- "\n"
<- "The run and rerun commands use the command interpreter indicated by the\n"
<- "environment variable SHELL to expand and interpret\n"
<- "the arguments and redirections.  dbx has built in knowledge of the\n"
<- "Bourne shell (sh) the C shell (csh) and the Korn shell (ksh).  If a user is\n"
<- "using a different shell, the run command will not be able to disable invocation\n"
<- "of the shell\'s initialization file (.cshrc, .kshrc, etc.)  This may cause the\n"
<- "run command to fail if the user\'s initialization file spawns off a program or a\n"
<- "sub shell.  If a non standard shell is used, the dbx variable $shellparameters\n"
<- "may be set to a string that will instruct the shell to skip loading of the\n"
<- "initialization file (for csh one would use \"-f\", for example.)  See the\n"
<- "description of $shellparameters in the $variables section for more information.\n"
<- "To verify exactly how your application is being started by the\n"
<- "run/rerun command, start dbx with the -d option (there is no way\n"
<- "to check how your application is started except by adding -d on\n"
<- "the command line, for example:  \"dbx -d a.out\".\n"
<- "This will show other data which you should ignore, but run might show, for\n"
<- "example, with /bin/csh as the SHELL:\n"
<- "More (n if no)?"
-> "\n"
<- "(gnome) r\n"
<- "Now execute givenfile with the following call:\n"
<- "execvp(\"/bin/csh\", \n"
<- "        \"/bin/csh,\n"
<- "        \"-f,\n"
<- "        \"-c,\n"
<- "        \"exec ./a.out,\n"
<- "        (char *)0);\n"
<- "Process 21473 (a.out) started\n"
<- "\n"
<- "If one wishes to debug a program with file-descriptors other than\n"
<- "the default 0,1,2 open, then care is required, since if $SHELL is\n"
<- "set to a C-shell, the extra file descriptors will be closed by\n"
<- "csh(1).  Instead, setenv SHELL /bin/sh (which means one can only use\n"
<- "sh-style redirections) for example, as sh(1) does not close the\n"
<- "extra file-descriptors.\n"
<- "\n"
<- "(dbx) "
-> "language\n"
<- "\n"
<- "\"language\" is not a valid command name.\n"
<- "error: language\n"
<- "               ^ Apparent syntax error in examine command. expected / ?\n"
<- "(dbx) "
-> "sh pwd\n"
<- "/build/zs/irix6.5m/work/irix/cmd/icrash\n"
<- "(dbx) "
-> "file\n"
<- "no current file\n"
<- "(dbx) "
-> "list\n"
<- "no current file\n"
<- "(dbx) "
-> "status\n"
<- "(dbx) "
-> "givenfile \n"
<- "No current givenfile\n"
<- "(dbx) "
-> "set $assignverify = 1\n"
<- "(dbx) "
-> "set $ctypenames = 1\n"
<- "(dbx) "
-> "set $fp_precise = 0\n"
<- "(dbx) "
-> "set $framereg = 1\n"
<- "(dbx) "
-> "set $groupforktoo = 0\n"
<- "(dbx) "
-> "set $hexchars = 0\n"
<- "(dbx) "
-> "set $hexdoubles = 0\n"
<- "(dbx) "
-> "set $hexin = 0\n"
<- "(dbx) "
-> "set $hexints = 1\n"
<- "(dbx) "
-> "set $hexstrings = 0\n"
<- "(dbx) "
-> "set $mp_program = 1\n"
<- "(dbx) "
-> "set $nonstop = 0\n"
<- "(dbx) "
-> "set $octin = 0\n"
<- "(dbx) "
-> "set $octints = 1\n"
<- "(dbx) "
-> "set $page = 1\n"
<- "(dbx) "
-> "set $pendingtraps = 0\n"
<- "(dbx) "
-> "set $piaddtohist = 1\n"
<- "(dbx) "
-> "set $pimode = 0\n"
<- "(dbx) "
-> "set $print_exception_frame = 0\n"
<- "(dbx) "
-> "set $printdata = 0\n"
<- "(dbx) "
-> "set $printwhilestep = 0\n"
<- "(dbx) "
-> "set $printwide = 0\n"
<- "(dbx) "
-> "set $regstyle = 1\n"
<- "(dbx) "
-> "set $repeatmode = 0\n"
<- "(dbx) "
-> "set $rimode = 0\n"
<- "(dbx) "
-> "set $searchstatics = 1\n"
<- "(dbx) "
-> "set $stdc = 0\n"
<- "(dbx) "
-> "set $stopformat = 0\n"
<- "(dbx) "
-> "set $addrfmt = \"0x%x\"\n"
<- "(dbx) "
-> "set $addrfmt64 = \"0x%llx\"\n"
<- "(dbx) "
-> "set $casesense = 2\n"
<- "(dbx) "
-> "set $editor = \"vim\"\n"
<- "(dbx) "
-> "set $lastchild = 0\n"
<- "(dbx) "
-> "set $lines = 20\n"
<- "(dbx) "
-> "set $listwindow = 10\n"
<- "(dbx) "
-> "set $maxstrlen = 128\n"
<- "(dbx) "
-> "set $pager = \"more\"\n"
<- "(dbx) "
-> "set $pagewidth = 80\n"
<- "(dbx) "
-> "set $pagewindow = 22\n"
<- "(dbx) "
-> "set $prompt = \"(dbx) \"\n"
<- "(dbx) "
-> "set $promptonfork = 0\n"
<- "(dbx) "
-> "set $shellparameters = \"\"\n"
<- "(dbx) "
-> "set $showbreakaddrs = 0\n"
<- "(dbx) "
-> "set $showfilename = 0\n"
<- "(dbx) "
-> "set $sourcepathrule = 0\n"
<- "(dbx) "
-> "set $stacktracelimit = 100\n"
<- "(dbx) "
-> "set $stepintoall = 0\n"
<- "(dbx) "
-> "set $tagfile = \"tags\"\n"
<- "(dbx) "
-> "set $whereisdsolimit = 1\n"
<- "(dbx) "
-> "# reset\n"
<- "\n"
<- "Syntax error: unrecognized command #\n"
<- "(dbx) "
-> "file\n"
<- "no current file\n"
<- "(dbx) "
-> "list\n"
<- "no current file\n"
<- "(dbx) "
-> "status\n"
<- "(dbx) "
-> "givenfile \n"
<- "No current givenfile\n"
<- "(dbx) "
-> "help detach\n"
<- "Invalid keyword detach\n"
<- "(dbx) "
#  Starting DBX...done.
#  Welcome to DDD 1998-11-25 "Nightsleeper" (mips-sgi-irix6.5)
-> "help run\n"
<- "run   arg1 arg2 ...            - begin execution of the program\n"
<- "rerun arg1 arg2 ...            - begin execution of the program\n"
<- "rerun                          - restart execution of the program\n"
<- "                                 with same arguments last used on run or rerun\n"
<- "\n"
<- "The run and rerun commands use the command interpreter indicated by the\n"
<- "environment variable SHELL to expand and interpret\n"
<- "the arguments and redirections.  dbx has built in knowledge of the\n"
<- "Bourne shell (sh) the C shell (csh) and the Korn shell (ksh).  If a user is\n"
<- "using a different shell, the run command will not be able to disable invocation\n"
<- "of the shell\'s initialization file (.cshrc, .kshrc, etc.)  This may cause the\n"
<- "run command to fail if the user\'s initialization file spawns off a program or a\n"
<- "sub shell.  If a non standard shell is used, the dbx variable $shellparameters\n"
<- "may be set to a string that will instruct the shell to skip loading of the\n"
<- "initialization file (for csh one would use \"-f\", for example.)  See the\n"
<- "description of $shellparameters in the $variables section for more information.\n"
<- "To verify exactly how your application is being started by the\n"
<- "run/rerun command, start dbx with the -d option (there is no way\n"
<- "to check how your application is started except by adding -d on\n"
<- "the command line, for example:  \"dbx -d a.out\".\n"
<- "This will show other data which you should ignore, but run might show, for\n"
<- "example, with /bin/csh as the SHELL:\n"
<- "More (n if no)?"
-> "\n"
<- "(gnome) r\n"
<- "Now execute givenfile with the following call:\n"
<- "execvp(\"/bin/csh\", \n"
<- "        \"/bin/csh,\n"
<- "        \"-f,\n"
<- "        \"-c,\n"
<- "        \"exec ./a.out,\n"
<- "        (char *)0);\n"
<- "Process 21473 (a.out) started\n"
<- "\n"
<- "If one wishes to debug a program with file-descriptors other than\n"
<- "the default 0,1,2 open, then care is required, since if $SHELL is\n"
<- "set to a C-shell, the extra file descriptors will be closed by\n"
<- "csh(1).  Instead, setenv SHELL /bin/sh (which means one can only use\n"
<- "sh-style redirections) for example, as sh(1) does not close the\n"
<- "extra file-descriptors.\n"
<- "\n"
<- "(dbx) "
-> "help step\n"
<- "step                           - single step 1 time.\n"
<- "step <int>                     - single step <int> times.\n"
<- "                                 \'step\' steps over procedures compiled without\n"
<- "                                 symbols by default.\n"
<- "                                 Breakpoints in procedures stepped over\n"
<- "                                 are honored.\n"
<- "                                 Functions coded entirely on one line cause\n"
<- "                                 step to act like stepi, since the actual\n"
<- "                                 code is all assigned one source line.\n"
<- "                                 Outstanding signals are ignored.\n"
<- "\n"
<- "  A step into a dso will fail (will result effectively in a \'next\')\n"
<- "  if rld(1) has not yet lazily evaluated the address of the function.\n"
<- "  Before rerunning the application, setenv LD_BIND_NOW 1\n"
<- "  will force rld to do immediate address resolution and will avoid\n"
<- "  the problem. \n"
<- "\n"
<- "(dbx) "
-> "help stepi\n"
<- "stepi                          - single step 1 assembly instruction\n"
<- "stepi <exp>                    - single step <exp> assembly instructions.\n"
<- "                                 See  $printwhilestep\n"
<- "\n"
<- "   A stepi into a dso will get into strange territory\n"
<- "   (rld(1) specifically)  and stack traces will not work\n"
<- "   well if rld(1) has not yet lazily evaluated the address\n"
<- "   of the function.  Before rerunning the application,\n"
<- "   setenv LD_BIND_NOW 1 will force rld to do immediate\n"
<- "   address resolution and will avoid the problem.\n"
<- "\n"
<- "nexti                          - like stepi, but step over subroutine calls\n"
<- "nexti <exp>                    - like stepi <exp>, but step over\n"
<- "                                 subroutine calls\n"
<- "$printwhilestep - if != 0, acts as if \'step[i] n\' was \'step[i]\' n times\n"
<- "(dbx) "
-> "help next\n"
<- "next                           - single step 1 time.      steps over procedures\n"
<- "next <int>                     - single step <int> times. steps over procedures\n"
<- "                                 \'next\' honors breakpoints in procedures\n"
<- "                                 stepped over.\n"
<- "                                 A consequence of this is that\n"
<- "                                 a ``stop if\'\' condition which is true will\n"
<- "                                 continue to be true -- making dbx stop after\n"
<- "                                 every statement in procedures one wanted to\n"
<- "                                 step over. Delete the ``stop if\'\'\n"
<- "                                 which has already become true to avoid the\n"
<- "                                 stops.\n"
<- "                                 Outstanding signals are ignored.\n"
<- "\n"
<- "(dbx) "
-> "help nexti\n"
<- "stepi                          - single step 1 assembly instruction\n"
<- "stepi <exp>                    - single step <exp> assembly instructions.\n"
<- "                                 See  $printwhilestep\n"
<- "\n"
<- "   A stepi into a dso will get into strange territory\n"
<- "   (rld(1) specifically)  and stack traces will not work\n"
<- "   well if rld(1) has not yet lazily evaluated the address\n"
<- "   of the function.  Before rerunning the application,\n"
<- "   setenv LD_BIND_NOW 1 will force rld to do immediate\n"
<- "   address resolution and will avoid the problem.\n"
<- "\n"
<- "nexti                          - like stepi, but step over subroutine calls\n"
<- "nexti <exp>                    - like stepi <exp>, but step over\n"
<- "                                 subroutine calls\n"
<- "$printwhilestep - if != 0, acts as if \'step[i] n\' was \'step[i]\' n times\n"
<- "(dbx) "
-> "help until\n"
<- "Invalid keyword until\n"
<- "(dbx) "
-> "help cont\n"
<- "cont                           - continue execution and wait until event\n"
<- "                                 see $promptonfork $mp_program and\n"
<- "                                 MULTIPLE PROCESS DEBUGGING for the\n"
<- "                                 behavior of this command with fork/exec/sproc\n"
<- "                                 If the program has a signal handler for\n"
<- "                                 a signal and the program stopped last on\n"
<- "                                 that signal, this passes the signal to\n"
<- "                                 the process on continuing.\n"
<- "cont <signal>                  - continue with signal and wait until event\n"
<- "                                 You must use the signal number or name\n"
<- "                                 unless the last stop for this process was\n"
<- "                                 via the desired signal.  Since it is difficult\n"
<- "                                 to be sure of this, it is simplest to\n"
<- "                                 use the <signal> clause.\n"
<- "cont at <line>                 - continue until <line> is reached\n"
<- "                                  (temporary breakpoint)\n"
<- "cont to <line>                 - same as \'continue at <line>\'\n"
<- "cont in <proc>                 - continue until <proc> is reached  (see above)\n"
<- "cont <signal> at <line>        - continue with signal until <line> (see above)\n"
<- "cont <signal> to <line>        - same as \'cont <signal> at <line>\'\n"
<- "cont <signal> in <proc>        - continue with signal until <proc> (see above)\n"
<- "More (n if no)?"
-> "\n"
<- "(dbx) "
-> "help signal\n"
<- "Invalid keyword signal\n"
<- "(dbx) "
-> "help kill\n"
<- "kill                           - kill active process\n"
<- "kill <pid> ...                 - kill process (list) specified\n"
<- "(dbx) "
-> "help up\n"
<- "up                             - move up one activation level in the stack\n"
<- "up <exp>                       - move up <exp> activation levels in the stack\n"
<- "down                           - move down one activation level in stack\n"
<- "down <exp>                     - move down <exp> activation levels in stack\n"
<- "(dbx) "
-> "help down\n"
<- "up                             - move up one activation level in the stack\n"
<- "up <exp>                       - move up <exp> activation levels in the stack\n"
<- "down                           - move down one activation level in stack\n"
<- "down <exp>                     - move down <exp> activation levels in stack\n"
<- "(dbx) "
#  Filtering files...
#  Filtering files...done.
-> "givenfile /build/zs/irix6.5m/work/irix/cmd/icrash/icrash\n"
<- "Executable /build/zs/irix6.5m/work/irix/cmd/icrash/icrash\n"
<- "(dbx) "
-> "file\n"
<- "/build/zs/irix6.5m/work/irix/cmd/icrash/main.c\n"
<- "(dbx) "
-> "list\n"
<- ">"
<- "*"
<- "  80  "
<- "{"
<- "\n"
<- " "
<- " "
<- "  81  "
<- "\tFILE *ofp;"
<- "\n"
<- " "
<- " "
<- "  82  "
<- "\tint i, c, errflg = 0;"
<- "\n"
<- " "
<- " "
<- "  83  "
<- "\tcommand_t cb;"
<- "\n"
<- " "
<- " "
<- "  84  "
<- "\n"
<- " "
<- " "
<- "  85  "
<- "\t/* getopt() variables.\n"
<- "    86  \t */\n"
<- "    87  \textern char *optarg;\n"
<- "    88  \textern int optind;\n"
<- "    89  \textern int opterr;\n"
<- "(dbx) "
-> "status\n"
<- "(dbx) "
#  Reading file "/build/zs/irix6.5m/work/irix/cmd/icrash/main.c"...
#  Reading file "/build/zs/irix6.5m/work/irix/cmd/icrash/main.c"...done.
#  File "/build/zs/irix6.5m/work/irix/cmd/icrash/main.c" 562 lines, 26460 characters
-> "givenfile \n"
<- "Current givenfile is /build/zs/irix6.5m/work/irix/cmd/icrash/icrash\n"
<- "(dbx) "
#  Debugged program will be executed in a separate execution window.
-> "commands\n"
<- "\n"
<- "\"commands\" is not a valid command name.\n"
<- "error: "
<- "commands\n"
<- " "
<- "              ^ Apparent syntax error in examine command. expected / ?\n"
<- "(dbx) "
#  Starting execution window...
+  /bin/sh -c 'tmp=${TMPDIR-/tmp}/ddd$$; export tmp; trap "rm -f $tmp" 0; trap '\''exit 1'\'' 1 2 15; xterm -bg '\''grey96'\'' -fg '\''black'\'' -cr '\''DarkGreen'\'' -fn '\''-*-lucidatypewriter-medium-r-*-*-*-100-*-*-*-*-iso8859-*'\'' -title '\''DDD: Execution Window'\'' -e /bin/sh -c '\''echo `tty` $$ $TERM $WINDOWID >$tmp; trap "" 2; while true; do sleep 3600; done'\'' >/dev/null </dev/null 2>&1 & while test ! -s $tmp; do sleep 1; done; cat $tmp'
#  Starting execution window...done.
#  Initializing execution window...
#  Initializing execution window...done.
-> "setenv TERM xterm\n"
<- "(dbx) "
-> "run < /dev/ttyq6 > /dev/ttyq6 -n 20\n"	<--ZS, my chosen params (-n 20)
						<-- note the output "corefile is
						<-- version 4"
<- "Process 74175 (icrash) started\n"
<- "corefile is version "
<- " 4"
<- "Process 74175 (icrash) terminated\n"
<- "(dbx) "
-> "file\n"
<- "no current file\n"
<- "(dbx) "
-> "status\n"
<- "(dbx) "
-> "print variables\n"
<- "Process 74175: "
<- "Appropriate symbol not found for: variables\n"
<- "<symbol not found>"
<- " "
<- "\n"
<- "(dbx) "
#  Initializing execution window...
#  Initializing execution window...done.
-> "setenv TERM xterm\n"
<- "(dbx) "
-> "rerun < /dev/ttyq6 > /dev/ttyq6\n"		<--ZS, rerun lost my params
						<--note I am not getting "corefile
						<-- is version 4" anymore,
						<-- rather I'm getting the output
						<-- (and errors) that is a
						<-- direct consequence of not
						<-- giving the right params
						<-- (-n 20) on the 'run' call
<- "Process 74188 (icrash) started\n"
<- "Cannot open corefile /dev/mem : Permission denied\n"
<- "Could not initialize libklib!\n"
<- "Process 74188 (icrash) terminated\n"
<- "(dbx) "
-> "file\n"
<- "no current file\n"
<- "(dbx) "
-> "status\n"
<- "(dbx) "
-> "quit\n"
#  Running DBX (pid 74129, tty /dev/ttyq5)...Exit 0.
#  Closing execution window...
#  Closing execution window...done.
#  Saving history in "/usr/people/zs/.ddd/history"...
#  Saving history in "/usr/people/zs/.ddd/history"...done.
#  Thanks for using DDD 1998-11-25!

--------------D0A4E813654E26B4571072D1--

