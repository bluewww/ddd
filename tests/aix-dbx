$Id$
This log tests the DDD `Sequence' capabilities.  Watch the OM_* members.

DDD 3.0 (powerpc-ibm-aix4.1.5.0), Copyright (C) 1998 TU Braunschweig.
Compiled with GCC egcs-2.90.29 980515 (egcs-1.0.3 release), libstdc++ 2.8.0
Requires X11R5, Xt11R5, Motif 1.2.3 (OSF/Motif Version 1.2.3)
Includes DDD core, manual, app-defaults, XPM 3.4.10, Athena Panner
Built 1998-06-29 by Jens Krinke  <jkrinke@watson.ibm.com>.
$  ddd --dbx writer
+  /bin/sh -c 'exec dbx '\''writer'\'''
#  Hello, world!
#  Starting DBX...
#  Raising core file size limit from 1073741312 to 2147483647 bytes...
#  Raising core file size limit from 1073741312 to 2147483647 bytes...done.
#  Running DBX (pid 43332, tty /dev/pts/6)...
#  DBX: EOF detected
<- "Type \'help\' for help.\n"
<- "reading symbolic information ..."
<- "\n"
<- "(dbx) "
-> "sh stty -echo -onlcr\n"
<- "(dbx) "
-> "set $page = 1\n"
<- "(dbx) "
-> "frame\n"
<- "frame\n"
<- "^ unrecognized command\n"
<- "(dbx) "
-> "func\n"
<- "main\n"
<- "(dbx) "
-> "dbxenv run_io\n"
<- "dbxenv run_io\n"
<- "^ unrecognized command\n"
<- "(dbx) "
-> "print -r 4711\n"
<- "\"r\" is not defined\n"
<- "(dbx) "
-> "where -h\n"
<- "__start() at 0x100001c8\n"
<- "where -h\n"
<- "      ^ syntax error\n"
<- "(dbx) "
-> "display\n"
<- "display\n"
<- "^ unrecognized command\n"
<- "(dbx) "
-> "clear\n"
<- "clear\n"
<- "     ^ syntax error\n"
<- "(dbx) "
-> "help handler\n"
<- "handler is not a known help topic or command\n"
<- "(dbx) "
-> "pwd\n"
<- "pwd\n"
<- "^ unrecognized command\n"
<- "(dbx) "
-> "help setenv\n"
<- "setenv is not a known help topic or command\n"
<- "(dbx) "
-> "help edit\n"
<- "edit\n"
<- "edit <filename>\n"
<- "edit <procedure>\n"
<- "\tInvoke an editor on <filename> or the current source file\n"
<- "\tif none is specified. If a procedure or function name\n"
<- "\tis specified the editor is invoked on the file that\n"
<- "\tcontains it. The default editor is the vi editor.\n"
<- "\tThe default can be overridden by setting the environment\n"
<- "\tvariable EDITOR to the name of the desired editor.\n"
<- "(dbx) "
-> "help make\n"
<- "make is not a known help topic or command\n"
<- "(dbx) "
-> "help regs\n"
<- "regs is not a known help topic or command\n"
<- "(dbx) "
-> "print \"DDD\"\n"
<- "DDD \n"
<- "(dbx) "
-> "help when\n"
<- "no help available for when\n"
<- "(dbx) "
-> "delete 4711 4711\n"
<- "unknown event 4711\n"
<- "(dbx) "
-> "help run\n"
<- "run [<arguments>] [< <filename>] [> <filename>] \n"
<- "                    [>> <filename>] [>! <filename>] \n"
<- "                    [2> <filename>] [2>> <filename>] \n"
<- "                    [>& <filename>] [>>& <filename>] \n"
<- "rerun [<arguments>] [< <filename>] [> <filename>] \n"
<- "                    [>> <filename>] [>! <filename>] \n"
<- "                    [2> <filename>] [2>> <filename>] \n"
<- "                    [>& <filename>] [>>& <filename>] \n"
<- "\tStart executing the object file, passing arguments as\n"
<- "\tcommand line arguments; < or > can be used to redirect\n"
<- "\tinput or output in a shell-like manner. When \"rerun\"\n"
<- "\tis used without any arguments the previous argument list\n"
<- "\tis passed to the program; otherwise it is identical to run.\n"
<- "(dbx) "
-> "help givenfile\n"
<- "givenfile is not a known help topic or command\n"
<- "(dbx) "
-> "help cont\n"
<- "cont\n"
<- "cont <signal-number>\n"
<- "cont <signal-name>\n"
<- "\tContinue execution from where it stopped. If a signal\n"
<- "\tis specified, the process continues as though it\n"
<- "\treceived the signal. Otherwise, the process is continued\n"
<- "\tas though it had not been stopped.\n"
<- "(dbx) "
-> "sh pwd\n"
<- "/u/jkrinke/src/dakota/builder\n"
<- "(dbx) "
-> "file\n"
<- "Writer.C\n"
<- "(dbx) "
-> "list\n"
<- "    1   #include <iostream.h>\n"
<- "    2   #include <stdlib.h>\n"
<- "    3   \n"
<- "    4   #include \"Dakota.H\"  \n"
<- "    5   #include \"Ohio.H\"\n"
<- "    6   #include \"FrontEnd.H\"\n"
<- "    7   #include \"MontanaFrontEnd.H\"\n"
<- "    8   #include \"WriterArg.H\"\n"
<- "    9   #include \"OhioFrontEnd.H\"\r\n"
<- "   10   \n"
<- "(dbx) "
-> "status\n"
<- "(dbx) "
#  Reading file "/u/jkrinke/src/dakota/builder/Writer.C"...
#  Reading file "/u/jkrinke/src/dakota/builder/Writer.C"...done.
#  File "/u/jkrinke/src/dakota/builder/Writer.C" 66 lines, 1604 characters
-> "debug \n"
<- "debug \n"
<- "      ^ syntax error\n"
<- "(dbx) "
-> "# reset\n"
<- "# reset\n"
<- "^ unrecognized command\n"
<- "(dbx) "
-> "file\n"
<- "Writer.C\n"
<- "(dbx) "
-> "list\n"
<- "   11   WriterArg arg;   // input arguments\n"
<- "   12   \n"
<- "   13   int main(int argc, char *argv[]) \n"
<- "   14   {\n"
<- "   15     // check which interface the user has used (menu or command line)\n"
<- "   16     if (argc == 2) \n"
<- "   17        arg.readMenuOptions();\n"
<- "   18     else\n"
<- "   19        arg.processCommandLineOptions(argc, argv);\n"
<- "   20   \n"
<- "(dbx) "
-> "status\n"
<- "(dbx) "
-> "debug \n"
<- "debug \n"
<- "      ^ syntax error\n"
<- "(dbx) "
-> "commands\n"
<- "commands\n"
<- "^ unrecognized command\n"
<- "(dbx) "
-> "help run\n"
<- "run [<arguments>] [< <filename>] [> <filename>] \n"
<- "                    [>> <filename>] [>! <filename>] \n"
<- "                    [2> <filename>] [2>> <filename>] \n"
<- "                    [>& <filename>] [>>& <filename>] \n"
<- "rerun [<arguments>] [< <filename>] [> <filename>] \n"
<- "                    [>> <filename>] [>! <filename>] \n"
<- "                    [2> <filename>] [2>> <filename>] \n"
<- "                    [>& <filename>] [>>& <filename>] \n"
<- "\tStart executing the object file, passing arguments as\n"
<- "\tcommand line arguments; < or > can be used to redirect\n"
<- "\tinput or output in a shell-like manner. When \"rerun\"\n"
<- "\tis used without any arguments the previous argument list\n"
<- "\tis passed to the program; otherwise it is identical to run.\n"
<- "(dbx) "
#  Starting DBX...done.
#  Welcome to DDD 3.0!
-> "help detach\n"
<- "detach\n"
<- "detach <sig_num>\n"
<- "detach <sig_name>\n"
<- "\tContinues execution from where it stopped without debugger\n"
<- "\tcontrol. If a signal is specified, the process continues\n"
<- "\tas though it received a signal. Otherwise, the debugger will\n"
<- "\texit, but the debugged process shall continue.\n"
<- "(dbx) "
-> "help step\n"
<- "step\n"
<- "step <count>\n"
<- "\tExecute one source line.\n"
<- "\tIf a count is supplied, execute the next count source lines.\n"
<- "\tThe difference between this and \"next\" is that if the line\n"
<- "\tcontains a call to a procedure or function the \"step\"\n"
<- "\tcommand will enter that procedure or function, while the \n"
<- "\t\"next\" command will not.\n"
<- "\tSee also: set_variables $stepignore\n"
<- "(dbx) "
-> "help stepi\n"
<- "stepi\n"
<- "stepi <count>\n"
<- "\tExecute a single instruction.\n"
<- "\tIf a count is supplied, execute the next count instructions.\n"
<- "(dbx) "
-> "help next\n"
<- "next\n"
<- "next <count>\n"
<- "\tExecute up to the next source line. If a count is supplied\n"
<- "\texecute the next count source lines. The difference between\n"
<- "\tthis and \"step\" is that if the line contains a call\n"
<- "\tto a procedure or function the \"step\" command will\n"
<- "\tstop at the beginning of that block, while the \"next\"\n"
<- "\tcommand will not.\n"
<- "(dbx) "
-> "help nexti\n"
<- "nexti\n"
<- "nexti <count>\n"
<- "\tSingle step as in \"next\", but do a single instruction\n"
<- "\trather than source line. If a count is supplied\n"
<- "\texecute the nexti count instructions.\n"
<- "(dbx) "
-> "help until\n"
<- "until is not a known help topic or command\n"
<- "(dbx) "
-> "help finish\n"
<- "finish is not a known help topic or command\n"
<- "(dbx) "
-> "help cont\n"
<- "cont\n"
<- "cont <signal-number>\n"
<- "cont <signal-name>\n"
<- "\tContinue execution from where it stopped. If a signal\n"
<- "\tis specified, the process continues as though it\n"
<- "\treceived the signal. Otherwise, the process is continued\n"
<- "\tas though it had not been stopped.\n"
<- "(dbx) "
-> "help signal\n"
<- "signal is not a known help topic or command\n"
<- "(dbx) "
-> "help kill\n"
<- "kill is not a known help topic or command\n"
<- "(dbx) "
-> "help up\n"
<- "up\n"
<- "up <count>\n"
<- "down\n"
<- "down <count>\n"
<- "\tMove the current function, which is used for resolving\n"
<- "\tnames, up or down the stack <count> levels. The default\n"
<- "\t<count> is one.\n"
<- "(dbx) "
-> "help down\n"
<- "up\n"
<- "up <count>\n"
<- "down\n"
<- "down <count>\n"
<- "\tMove the current function, which is used for resolving\n"
<- "\tnames, up or down the stack <count> levels. The default\n"
<- "\t<count> is one.\n"
<- "(dbx) "
-> "file Writer.C\n"
<- "(dbx) "
-> "status\n"
<- "(dbx) "
-> "stop at 35\n"
<- "[1] stop at \"Writer.C\":35\n"
<- "(dbx) "
-> "status\n"
<- "[1] stop at \"Writer.C\":35\n"
<- "(dbx) "
-> "rerun includes.prj\n"
<- "HeapMonitor: starting (HeapMonitorEnableAccounting=0, HeapMonitorEnableArenaAccounting=0, HeapMonitorReportUnreclaimedObjects=0, HeapMonitorEnablePatternFill=0)\n"
<- "\n"
<- "\n"
<- "\n"
<- "\n"
<- "\n"
<- "        WRITER  Menu\n"
<- "\n"
<- " -Displace Trace Information [y/n]?  (default=n) "
-> "\n"
<- " -Generate NARC files [y/n]?  (default=n) "
-> "\n"
<- " -Write the Ohio File twice [y/n]?  (default=n) "
-> "\n"
<- "\n"
<- "Using Montana to construct PCG and CFGs for \'includes.prj\'.\n"
<- "   Incoporation Time: 5.62 seconds.\n"
<- "File incorporated by Montana....\n"
<- "[1] stopped in main at line 35 in file \"Writer.C\"\n"
<- "   35     if (arg.narc())\n"
<- "(dbx) "
-> "file\n"
<- "Writer.C\n"
<- "(dbx) "
-> "status\n"
<- "[1] stop at \"Writer.C\":35\n"
<- "(dbx) "
-> "print \"else =\", else\n"
<- "\"else\" is not defined\n"
<- "(dbx) "
-> "print \"pcg =\", pcg\n"
<- "pcg =     OM_PCGDownCasters:()\n"
<- "(_root = 0x2004c248, _functionList = (_first = 0x2004c248, _last = 0x2004c248), _frontEnd = (_fileName = \"includes.prj\", _factory = \n"
<- "                OM_FactoryDownCasters:()\n"
<- "            (), \n"
<- " _symboltable = (_table = (\n"
<- "(_first = (nil), _last = (nil))\n"
<- "(_first = 0x20050428, _last = 0x20050428)\n"
<- "(_first = (nil), _last = (nil))\n"
<- "), _iteratorIndex = 0, _numEntries = 1), _buildTime = 0.0), _directoryName = \"includes.results\", _baseFileName = \"includes\", _forward = (_first = 0x20050658, _last = 0x20050658), _backward = (_first = 0x2004c2b8, _last = 0x2004c2b8), _forwardNext = (nil), _backwardNext = (nil), _topSortListSize = 1, _isRecursive = 0, _historyStack = (_first = (nil), _last = (nil))) \n"
<- "(dbx) "
-> "list pcg\n"
<- "no source lines for \"(noname)\"\n"
<- "(dbx) "
-> "func\n"
<- "main\n"
<- "(dbx) "
-> "quit\n"
#  Running DBX (pid 43332, tty /dev/pts/6)...Exit 0.
#  Saving history in "/u/jkrinke/.ddd/history"...
#  Saving history in "/u/jkrinke/.ddd/history"...done.
#  Thanks for using DDD 3.0!
