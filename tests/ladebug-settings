GNU DDD 3.2 (alphaev56-dec-osf4.0d)
Copyright (C) 1995-1999 Technische Universitaet Braunschweig, Germany.
Copyright (C) 1999-2000 Universitaet Passau, Germany.
Compiled with cxx
Requires X11R6, Xt11R6, Motif 1.2.4 (OSF/Motif Version 1.2.4)
Includes DDD core, Manual, App defaults, XPM 3.4.11, Athena Panner
Built 2000-02-09 by Soeren Rex <srex@psi.de>.
$  ./ddd --ladebug cxxtest
+  /bin/sh -c 'exec ladebug '\''cxxtest'\'''
#  Hello, world!
#  Starting Ladebug...
#  Running Ladebug (pid 2229, tty /dev/ttyp5)...
#  Current language: c/c++
<- "Welcome to the Ladebug Debugger Version 4.0-48"
<- "------------------ "
<- "object file name: cxxtest "
<- "Reading symbolic information ...done"
<- "(ladebug) "
-> "sh stty -echo -onlcr"
<- "\033[J "
<- "\033[D\033[D\033[D\033[D\033[D\033[J "
<- "(ladebug) "
-> "set $page = 1"
<- "\033[J "
<- "(ladebug) "
-> "frame"
<- "\033[J "
<- "frame"
<- "    ^"
<- "Unable to parse input as legal command or C++ expression."
<- "(ladebug) "
-> "func"
<- "\033[J "
<- "int main(int, char**) in ./cxxtest.C line No. 509:"
<- "    509     int i = 42;"
<- "(ladebug) "
-> "dbxenv run_io"
<- "\033[J "
<- "dbxenv run_io"
<- "            ^"
<- "Unable to parse input as legal command or C++ expression."
<- "(ladebug) "
-> "print -r 4711"
<- "\033[J "
<- "print -r 4711"
<- "            ^"
<- "Unable to parse input as legal command or C++ expression."
<- "(ladebug) "
-> "where -h"
<- "\033[J "
<- "The \"where\" command has failed because there is no running program."
<- "(ladebug) "
-> "display"
<- "\033[J "
<- "display"
<- "      ^"
<- "Unable to parse input as legal command or C++ expression."
<- "(ladebug) "
-> "clear"
<- "\033[J "
<- "clear"
<- "    ^"
<- "Unable to parse input as legal command or C++ expression."
<- "(ladebug) "
-> "help handler"
<- "\033[J "
<- "Information about \"handler\" isn\'t available"
<- ""
<- ""
<- ""
<- "Welcome to the Ladebug debugger help system. "
<- " "
<- "To find out about:  "
<- " "
<- "        - starting up a program in Ladebug "
<- "                enter \'help start\' "
<- " "
<- "        - stopping at a specific place in your program "
<- "                enter \'help breakpoint\' "
<- " "
<- "        - making the program execute "
<- "                enter \'help execution\' "
<- " "
<- "        - saving or cloning a snapshot of the current process "
<- "                enter \'help snapshot\' "
<- " "
<- "        - determining the type or value of a program variable "
<- "                enter \'help variable\' "
<- " "
<- "        - reading or writing a memory location "
<- "                enter \'help memory\' "
<- " "
<- "        - reading or writing a register "
<- "                enter \'help register\' "
<- " "
<- "        - showing the current call stack "
<- "                enter \'help stack\' "
<- " "
<- "        - displaying the source text of your program "
<- "                enter \'help listing\' "
<- " "
<- "        - listing all of the ladebug commands "
<- "                enter \'help ladebug\' or \'help command\' "
<- " "
<- "To find out about all of the Ladebug commands, use "
<- "\'help ladebug\' or \'help command\'.  To find out about  "
<- "a specific command, use help, followed by the command  "
<- "verb, such as \'help quit\'."
<- "(ladebug) "
-> "pwd"
<- "\033[J "
<- "pwd"
<- "  ^"
<- "Unable to parse input as legal command or C++ expression."
<- "(ladebug) "
-> "help setenv"
<- "\033[J "
<- ""
<- "        setenv [<env_variable> [<value>]] "
<- ""
<- "Sets the value of the specified environment variable. If no variable "
<- "is specified, the command displays the values of all environment "
<- "variables. If a variable is specified but no value is specified, then "
<- "the variable is set to NULL. "
<- ""
<- "This command is not for the current debuggee\'s environment, but for "
<- "the environment of any debuggees subsequently created with fork(2) or "
<- "with subsequent \'run\' or \'rerun\' commands. "
<- ""
<- "\'export\' and \'setenv\' are synonyms. "
<- ""
<- "See the Ladebug Debugger Manual for more information on commands that "
<- "manipulate the environment of subsequent debuggees. "
<- "(ladebug) "
-> "help edit"
<- "\033[J "
<- "Information about \"edit\" isn\'t available"
<- ""
<- ""
<- ""
<- "Welcome to the Ladebug debugger help system. "
<- " "
<- "To find out about:  "
<- " "
<- "        - starting up a program in Ladebug "
<- "                enter \'help start\' "
<- " "
<- "        - stopping at a specific place in your program "
<- "                enter \'help breakpoint\' "
<- " "
<- "        - making the program execute "
<- "                enter \'help execution\' "
<- " "
<- "        - saving or cloning a snapshot of the current process "
<- "                enter \'help snapshot\' "
<- " "
<- "        - determining the type or value of a program variable "
<- "                enter \'help variable\' "
<- " "
<- "        - reading or writing a memory location "
<- "                enter \'help memory\' "
<- " "
<- "        - reading or writing a register "
<- "                enter \'help register\' "
<- " "
<- "        - showing the current call stack "
<- "                enter \'help stack\' "
<- " "
<- "        - displaying the source text of your program "
<- "                enter \'help listing\' "
<- " "
<- "        - listing all of the ladebug commands "
<- "                enter \'help ladebug\' or \'help command\' "
<- " "
<- "To find out about all of the Ladebug commands, use "
<- "\'help ladebug\' or \'help command\'.  To find out about  "
<- "a specific command, use help, followed by the command  "
<- "verb, such as \'help quit\'."
<- "(ladebug) "
-> "help make"
<- "\033[J "
<- "Information about \"make\" isn\'t available"
<- ""
<- ""
<- ""
<- "Welcome to the Ladebug debugger help system. "
<- " "
<- "To find out about:  "
<- " "
<- "        - starting up a program in Ladebug "
<- "                enter \'help start\' "
<- " "
<- "        - stopping at a specific place in your program "
<- "                enter \'help breakpoint\' "
<- " "
<- "        - making the program execute "
<- "                enter \'help execution\' "
<- " "
<- "        - saving or cloning a snapshot of the current process "
<- "                enter \'help snapshot\' "
<- " "
<- "        - determining the type or value of a program variable "
<- "                enter \'help variable\' "
<- " "
<- "        - reading or writing a memory location "
<- "                enter \'help memory\' "
<- " "
<- "        - reading or writing a register "
<- "                enter \'help register\' "
<- " "
<- "        - showing the current call stack "
<- "                enter \'help stack\' "
<- " "
<- "        - displaying the source text of your program "
<- "                enter \'help listing\' "
<- " "
<- "        - listing all of the ladebug commands "
<- "                enter \'help ladebug\' or \'help command\' "
<- " "
<- "To find out about all of the Ladebug commands, use "
<- "\'help ladebug\' or \'help command\'.  To find out about  "
<- "a specific command, use help, followed by the command  "
<- "verb, such as \'help quit\'."
<- "(ladebug) "
-> "help regs"
<- "\033[J "
<- "Information about \"regs\" isn\'t available"
<- ""
<- ""
<- ""
<- "Welcome to the Ladebug debugger help system. "
<- " "
<- "To find out about:  "
<- " "
<- "        - starting up a program in Ladebug "
<- "                enter \'help start\' "
<- " "
<- "        - stopping at a specific place in your program "
<- "                enter \'help breakpoint\' "
<- " "
<- "        - making the program execute "
<- "                enter \'help execution\' "
<- " "
<- "        - saving or cloning a snapshot of the current process "
<- "                enter \'help snapshot\' "
<- " "
<- "        - determining the type or value of a program variable "
<- "                enter \'help variable\' "
<- " "
<- "        - reading or writing a memory location "
<- "                enter \'help memory\' "
<- " "
<- "        - reading or writing a register "
<- "                enter \'help register\' "
<- " "
<- "        - showing the current call stack "
<- "                enter \'help stack\' "
<- " "
<- "        - displaying the source text of your program "
<- "                enter \'help listing\' "
<- " "
<- "        - listing all of the ladebug commands "
<- "                enter \'help ladebug\' or \'help command\' "
<- " "
<- "To find out about all of the Ladebug commands, use "
<- "\'help ladebug\' or \'help command\'.  To find out about  "
<- "a specific command, use help, followed by the command  "
<- "verb, such as \'help quit\'."
<- "(ladebug) "
-> "print \"DDD\""
<- "\033[J "
<- "DDD"
<- "(ladebug) "
-> "help when"
<- "\033[J "
<- ""
<- "\twhen {<command>[;...]} "
<- "\twhen if <expression> {<command>[;...]} "
<- "\twhen at <line_number> [if <expression>] {<command>[;...]} "
<- "\twhen in function [if <expression>] {<command>[;...]} "
<- "\twhen [thread <thread_identifier_list>] "
<- "\t [at <line_number>] [if <expression>] {<command>[;...]} "
<- "\twhen [thread <thread_identifier_list>] "
<- "\t [in <function>] [if <expression>] {<command>[;...]} "
<- ""
<- "Use the \'when\' command to execute the specified command. "
<- "(The \'when\' command does not suspend program execution.) "
<- "The debugger command must be enclosed in braces. Separate multiple "
<- "commands with semicolons. "
<- ""
<- "To execute a command when an expression evaluates true, use the second form. "
<- "To execute commands when a line or function is encountered, use the third "
<- "or fourth form. "
<- ""
<- "If you specify an expression, the command is executed only if the "
<- "expression evaluates true when the line or function is encountered. "
<- ""
<- "Use the \'when thread\' command to set tracepoints in specific threads. "
<- "If you list one or more thread identifiers, the debugger sets a tracepoint "
<- "only in those threads you specify.  If you omit the thread identifier "
<- "specification, the ebugger sets a tracepoint in all the threads of the "
<- "application. "
<- "(ladebug) "
-> "delete 4711 4711"
<- "\033[J "
<- "delete 4711 4711"
<- "               ^"
<- "Unable to parse input as legal command or C++ expression."
<- "(ladebug) "
-> "help run"
<- "\033[J "
<- ""
<- "        run [<program arguments>] [<io redirection>] "
<- "        rerun [<program arguments>] [<io redirection>] "
<- ""
<- "Use the \'run\' and \'rerun\' commands to start program execution. "
<- "Enter program flags, options, and input and output redirections "
<- "as arguments. If the \'rerun\' command is specified without "
<- "arguments, the arguments entered with the previous \'run\' "
<- "command are used.  If the last modification time and/or "
<- "size of the binary file or any of the shared objects used "
<- "by the binary file has changed since the last \'run\' command "
<- "was issued,  Ladebug automatically rereads the symbol "
<- "table information.  If this happens, the old breakpoint "
<- "settings may no longer be valid after the new symbol table "
<- "information is read. "
<- "(ladebug) "
-> "help givenfile"
<- "\033[J "
<- "Information about \"givenfile\" isn\'t available"
<- ""
<- ""
<- ""
<- "Welcome to the Ladebug debugger help system. "
<- " "
<- "To find out about:  "
<- " "
<- "        - starting up a program in Ladebug "
<- "                enter \'help start\' "
<- " "
<- "        - stopping at a specific place in your program "
<- "                enter \'help breakpoint\' "
<- " "
<- "        - making the program execute "
<- "                enter \'help execution\' "
<- " "
<- "        - saving or cloning a snapshot of the current process "
<- "                enter \'help snapshot\' "
<- " "
<- "        - determining the type or value of a program variable "
<- "                enter \'help variable\' "
<- " "
<- "        - reading or writing a memory location "
<- "                enter \'help memory\' "
<- " "
<- "        - reading or writing a register "
<- "                enter \'help register\' "
<- " "
<- "        - showing the current call stack "
<- "                enter \'help stack\' "
<- " "
<- "        - displaying the source text of your program "
<- "                enter \'help listing\' "
<- " "
<- "        - listing all of the ladebug commands "
<- "                enter \'help ladebug\' or \'help command\' "
<- " "
<- "To find out about all of the Ladebug commands, use "
<- "\'help ladebug\' or \'help command\'.  To find out about  "
<- "a specific command, use help, followed by the command  "
<- "verb, such as \'help quit\'."
<- "(ladebug) "
-> "help cont"
<- "\033[J "
<- ""
<- "        cont [<signal>] [to <line_number>] "
<- "        cont [in <function>] "
<- ""
<- "Use the \'cont\' command without a parameter value to resume program "
<- "execution until a breakpoint, a signal, an error, or the end of "
<- "the program is encountered.  Specify a signal parameter value to send "
<- "an operating system signal to the program continuing execution. "
<- "Specify a to line_number parameter value to halt program execution "
<- "when that line number is reached. "
<- ""
<- "When you use the \'cont\' commmand, Ladebug resumes execution of the "
<- "entire process. "
<- ""
<- "The signal parameter value can be either a signal number or a "
<- "string name (for example, SIGSEGV).  The default is 0, which "
<- "allows the program to continue execution without specifying a "
<- "signal.  If you specify a signal parameter value, the program "
<- "continues execution with that signal. "
<- ""
<- "The \'to line_number\' parameter value is used to resume execution and "
<- "then halt when the specified source line is reached. "
<- ""
<- "The form of the optional line_number argument must be one of the "
<- "following: "
<- "\t- line_number, a positive numeric, which indicates the "
<- "           line number of the current source file where execution "
<- "           is to be halted "
<- "        - \"filename\":line_number, which explicitly identifies both "
<- " \t  the source file and the line number where execution "
<- "          is to be halted. "
<- ""
<- "If the optional function name is provided, execution will be halted "
<- "when that function is reached.  This form of the \'cont\' command does "
<- "not support signals.  If the function name is overloaded, the user is "
<- "prompted with a choice of overloaded function names or \'none of the above\'. "
<- "Depending on user choice, program execution continues until the "
<- "specified function is reached or warns the user that no breakpoint is set."
<- "If the \'none of the above\' option is specified, program execution returns "
<- "to the \'ladebug\' prompt."
<- "(ladebug) "
-> "help examine"
<- "\033[J "
<- "Information about \"examine\" isn\'t available"
<- ""
<- ""
<- ""
<- "Welcome to the Ladebug debugger help system. "
<- " "
<- "To find out about:  "
<- " "
<- "        - starting up a program in Ladebug "
<- "                enter \'help start\' "
<- " "
<- "        - stopping at a specific place in your program "
<- "                enter \'help breakpoint\' "
<- " "
<- "        - making the program execute "
<- "                enter \'help execution\' "
<- " "
<- "        - saving or cloning a snapshot of the current process "
<- "                enter \'help snapshot\' "
<- " "
<- "        - determining the type or value of a program variable "
<- "                enter \'help variable\' "
<- " "
<- "        - reading or writing a memory location "
<- "                enter \'help memory\' "
<- " "
<- "        - reading or writing a register "
<- "                enter \'help register\' "
<- " "
<- "        - showing the current call stack "
<- "                enter \'help stack\' "
<- " "
<- "        - displaying the source text of your program "
<- "                enter \'help listing\' "
<- " "
<- "        - listing all of the ladebug commands "
<- "                enter \'help ladebug\' or \'help command\' "
<- " "
<- "To find out about all of the Ladebug commands, use "
<- "\'help ladebug\' or \'help command\'.  To find out about  "
<- "a specific command, use help, followed by the command  "
<- "verb, such as \'help quit\'."
<- "(ladebug) "
-> "help rerun"
<- "\033[J "
<- ""
<- "        run [<program arguments>] [<io redirection>] "
<- "        rerun [<program arguments>] [<io redirection>] "
<- ""
<- "Use the \'run\' and \'rerun\' commands to start program execution. "
<- "Enter program flags, options, and input and output redirections "
<- "as arguments. If the \'rerun\' command is specified without "
<- "arguments, the arguments entered with the previous \'run\' "
<- "command are used.  If the last modification time and/or "
<- "size of the binary file or any of the shared objects used "
<- "by the binary file has changed since the last \'run\' command "
<- "was issued,  Ladebug automatically rereads the symbol "
<- "table information.  If this happens, the old breakpoint "
<- "settings may no longer be valid after the new symbol table "
<- "information is read. "
<- "(ladebug) "
-> "language"
<- "\033[J "
<- "language"
<- "       ^"
<- "Unable to parse input as legal command or C++ expression."
<- "(ladebug) "
-> "sh pwd"
<- "\033[J "
<- "/gowd/ems/emssr/ddd/ddd-3.2/ddd"
<- "(ladebug) "
-> "file"
<- "\033[J "
<- "./cxxtest.C"
<- "(ladebug) "
-> "list"
<- "\033[J "
<- "    510     tree_test();"
<- "    511     i++;"
<- "    512     list_test(i);"
<- "    513     i++;"
<- "    514     array_test();"
<- "    515     i++;"
<- "    516     string_test();"
<- "    517     i++;"
<- "    518     plot_test();"
<- "    519     i++;"
<- "    520     type_test();"
<- "    521     --i;"
<- "    522     cin_cout_test();"
<- "    523     return 0;"
<- "    524 }"
<- "(ladebug) "
-> "status"
<- "\033[J "
<- "(ladebug) "
#  Reading file "/gowd/ems/emssr/ddd/ddd-3.2/ddd/cxxtest.C"...
#  Reading file "/gowd/ems/emssr/ddd/ddd-3.2/ddd/cxxtest.C"...done.
#  File "/gowd/ems/emssr/ddd/ddd-3.2/ddd/cxxtest.C" 524 lines, 11901 characters
#  Setting buttons...
#  Setting buttons...done.
-> "debug "
<- "\033[J "
<- "debug "
<- "     ^"
<- "Unable to parse input as legal command or C++ expression."
<- "(ladebug) "
-> "# reset"
<- "\033[J "
<- "(ladebug) "
-> "file"
<- "\033[J "
<- "./cxxtest.C"
<- "(ladebug) "
-> "list"
<- "\033[J "
<- "(File ./cxxtest.C has only 524 lines; the current line number is 525)"
<- "(ladebug) "
-> "status"
<- "\033[J "
<- "(ladebug) "
-> "setenv TERM dumb"
<- "\033[J "
<- "(ladebug) "
-> "debug "
<- "\033[J "
<- "debug "
<- "     ^"
<- "Unable to parse input as legal command or C++ expression."
<- "(ladebug) "
#  Starting Ladebug...done.
#  Welcome to DDD 3.2 "Man Ray" (alphaev56-dec-osf4.0d)
-> "commands"
<- "\033[J "
<- "commands"
<- "       ^"
<- "Unable to parse input as legal command or C++ expression."
<- "(ladebug) "
-> "help run"
<- "\033[J "
<- ""
<- "        run [<program arguments>] [<io redirection>] "
<- "        rerun [<program arguments>] [<io redirection>] "
<- ""
<- "Use the \'run\' and \'rerun\' commands to start program execution. "
<- "Enter program flags, options, and input and output redirections "
<- "as arguments. If the \'rerun\' command is specified without "
<- "arguments, the arguments entered with the previous \'run\' "
<- "command are used.  If the last modification time and/or "
<- "size of the binary file or any of the shared objects used "
<- "by the binary file has changed since the last \'run\' command "
<- "was issued,  Ladebug automatically rereads the symbol "
<- "table information.  If this happens, the old breakpoint "
<- "settings may no longer be valid after the new symbol table "
<- "information is read. "
<- "(ladebug) "
-> "help detach"
<- "\033[J "
<- ""
<- "        detach [process_id_list] "
<- ""
<- "Use the \'detach\' command to detach from a running process you specify "
<- "from the process ID list.  Specifying a process ID and detaching from "
<- "the process disables your ability to debug the process.  If you do not "
<- "specify a process ID from the list, Ladebug detaches from the "
<- "current process. "
<- "(ladebug) "
-> "help step"
<- "\033[J "
<- ""
<- "        step [<expression>]"
<- ""
<- "Use the \'next\' and \'step\' commands to execute a line of source "
<- "code.  When the next line to be executed contains a function call, "
<- "the \'next\' command executes the function being called and returns "
<- "to the line immediately after the function call. The \'step\' "
<- "command steps into the function and executes only the first line "
<- "of the function. "
<- ""
<- "For multithreaded applications, use these commands to step the "
<- "current thread while putting all other threads on hold. "
<- ""
<- "If the optional <expression> argument is supplied, Ladebug will "
<- "evaluate the number of times to execute the command.  The expression "
<- "can be any expression that is valid within the current context. "
<- "(ladebug) "
-> "help stepi"
<- "\033[J "
<- ""
<- "        stepi [<expression>]"
<- ""
<- "Use the \'stepi\' command and the \'nexti\' command to execute a "
<- "machine instruction. When the instruction contains a function call, "
<- "the \'stepi\' command steps into the function being called, and the "
<- "\'nexti\' command executes the function being called. "
<- ""
<- "For multithreaded applications, use these commands to step the "
<- "current thread while putting all other threads on hold. "
<- ""
<- "If the optional <expression> argument is supplied, Ladebug will "
<- "evaluate the number of times to execute the command.  The expression "
<- "can be any expression that is valid within the current context. "
<- "(ladebug) "
-> "help next"
<- "\033[J "
<- ""
<- "        next [<expression>] "
<- ""
<- "Use the \'next\' and \'step\' commands to execute a line of source "
<- "code.  When the next line to be executed contains a function call, "
<- "the \'next\' command executes the function being called and returns "
<- "to the line immediately after the function call.  The \'step\' "
<- "command executes only the first line of the function. "
<- ""
<- "For multithreaded applications, use these commands to step the "
<- "current thread while putting all other threads on hold. "
<- ""
<- "If the optional <expression> argument is supplied, Ladebug will "
<- "evaluate the number of times to execute the command.  The expression "
<- "can be any expression that is valid within the current context. "
<- "(ladebug) "
-> "help nexti"
<- "\033[J "
<- ""
<- "        nexti [<expression>] "
<- ""
<- "Use the \'stepi\' command and the \'nexti\' command to execute a "
<- "machine instruction.  When the instruction contains a function "
<- "call, the \'stepi\' command steps into the function being called, "
<- "and the \'nexti\' command executes the function being called. "
<- ""
<- "For multithreaded applications, use these commands to step the "
<- "current thread while putting all other threads on hold. "
<- ""
<- "If the optional <expression> argument is supplied, Ladebug will "
<- "evaluate the number of times to execute the command.  The expression "
<- "can be any expression that is valid within the current context. "
<- "(ladebug) "
-> "help until"
<- "\033[J "
<- "Information about \"until\" isn\'t available"
<- ""
<- ""
<- ""
<- "Welcome to the Ladebug debugger help system. "
<- " "
<- "To find out about:  "
<- " "
<- "        - starting up a program in Ladebug "
<- "                enter \'help start\' "
<- " "
<- "        - stopping at a specific place in your program "
<- "                enter \'help breakpoint\' "
<- " "
<- "        - making the program execute "
<- "                enter \'help execution\' "
<- " "
<- "        - saving or cloning a snapshot of the current process "
<- "                enter \'help snapshot\' "
<- " "
<- "        - determining the type or value of a program variable "
<- "                enter \'help variable\' "
<- " "
<- "        - reading or writing a memory location "
<- "                enter \'help memory\' "
<- " "
<- "        - reading or writing a register "
<- "                enter \'help register\' "
<- " "
<- "        - showing the current call stack "
<- "                enter \'help stack\' "
<- " "
<- "        - displaying the source text of your program "
<- "                enter \'help listing\' "
<- " "
<- "        - listing all of the ladebug commands "
<- "                enter \'help ladebug\' or \'help command\' "
<- " "
<- "To find out about all of the Ladebug commands, use "
<- "\'help ladebug\' or \'help command\'.  To find out about  "
<- "a specific command, use help, followed by the command  "
<- "verb, such as \'help quit\'."
<- "(ladebug) "
-> "help cont"
<- "\033[J "
<- ""
<- "        cont [<signal>] [to <line_number>] "
<- "        cont [in <function>] "
<- ""
<- "Use the \'cont\' command without a parameter value to resume program "
<- "execution until a breakpoint, a signal, an error, or the end of "
<- "the program is encountered.  Specify a signal parameter value to send "
<- "an operating system signal to the program continuing execution. "
<- "Specify a to line_number parameter value to halt program execution "
<- "when that line number is reached. "
<- ""
<- "When you use the \'cont\' commmand, Ladebug resumes execution of the "
<- "entire process. "
<- ""
<- "The signal parameter value can be either a signal number or a "
<- "string name (for example, SIGSEGV).  The default is 0, which "
<- "allows the program to continue execution without specifying a "
<- "signal.  If you specify a signal parameter value, the program "
<- "continues execution with that signal. "
<- ""
<- "The \'to line_number\' parameter value is used to resume execution and "
<- "then halt when the specified source line is reached. "
<- ""
<- "The form of the optional line_number argument must be one of the "
<- "following: "
<- "\t- line_number, a positive numeric, which indicates the "
<- "           line number of the current source file where execution "
<- "           is to be halted "
<- "        - \"filename\":line_number, which explicitly identifies both "
<- " \t  the source file and the line number where execution "
<- "          is to be halted. "
<- ""
<- "If the optional function name is provided, execution will be halted "
<- "when that function is reached.  This form of the \'cont\' command does "
<- "not support signals.  If the function name is overloaded, the user is "
<- "prompted with a choice of overloaded function names or \'none of the above\'. "
<- "Depending on user choice, program execution continues until the "
<- "specified function is reached or warns the user that no breakpoint is set."
<- "If the \'none of the above\' option is specified, program execution returns "
<- "to the \'ladebug\' prompt."
<- "(ladebug) "
-> "help signal"
<- "\033[J "
<- "Information about \"signal\" isn\'t available"
<- ""
<- ""
<- ""
<- "Welcome to the Ladebug debugger help system. "
<- " "
<- "To find out about:  "
<- " "
<- "        - starting up a program in Ladebug "
<- "                enter \'help start\' "
<- " "
<- "        - stopping at a specific place in your program "
<- "                enter \'help breakpoint\' "
<- " "
<- "        - making the program execute "
<- "                enter \'help execution\' "
<- " "
<- "        - saving or cloning a snapshot of the current process "
<- "                enter \'help snapshot\' "
<- " "
<- "        - determining the type or value of a program variable "
<- "                enter \'help variable\' "
<- " "
<- "        - reading or writing a memory location "
<- "                enter \'help memory\' "
<- " "
<- "        - reading or writing a register "
<- "                enter \'help register\' "
<- " "
<- "        - showing the current call stack "
<- "                enter \'help stack\' "
<- " "
<- "        - displaying the source text of your program "
<- "                enter \'help listing\' "
<- " "
<- "        - listing all of the ladebug commands "
<- "                enter \'help ladebug\' or \'help command\' "
<- " "
<- "To find out about all of the Ladebug commands, use "
<- "\'help ladebug\' or \'help command\'.  To find out about  "
<- "a specific command, use help, followed by the command  "
<- "verb, such as \'help quit\'."
<- "(ladebug) "
-> "help kill"
<- "\033[J "
<- ""
<- "        kill "
<- ""
<- "Use the \'kill\' command to terminate the program process leaving "
<- "the debugger running.  When a process terminates, any breakpoints "
<- "and traces previously set are retained.  You can later rerun the "
<- "program. "
<- "(ladebug) "
-> "help up"
<- "\033[J "
<- ""
<- "        up [<integer>] "
<- ""
<- "Use the \'up\' command or the \'down\' command without an argument to change the "
<- "function scope to the function located one level up or down the stack.  "
<- ""
<- "Enter a number argument to change the function scope to the function "
<- "up or down the specified number of levels. If the number of levels "
<- "exceeds the number of active functions on the stack, the function "
<- "scope moves up or down as many levels as possible and the debugger "
<- "issues a warning message. "
<- ""
<- "When the function scope changes, the debugger displays the source line "
<- "corresponding to the last point of execution in that function. "
<- "(ladebug) "
-> "help down"
<- "\033[J "
<- "\033[D\033[D\033[D\033[J "
<- ""
<- "        down [<integer>] "
<- ""
<- "Use the \'up\' command or the \'down\' command without an argument to "
<- "change the function scope to the function located one level up or "
<- "down the stack. "
<- ""
<- "Enter a number argument to change the function scope to the "
<- "function up or down the specified number of levels.  If the number "
<- "of levels exceeds the number of active functions on the stack, "
<- "the function scope moves up or down as many levels as possible "
<- "and the debugger issues a warning message. "
<- ""
<- "When the function scope changes, the debugger displays the source "
<- "line corresponding to the last point of execution in the function."
<- "(ladebug) "
#  Retrieving Ladebug Settings...
#  Retrieving Ladebug Settings...
-> "dbxenv"
<- "\033[J"
<- " "
<- "\033[C"
<- "\033[D"
<- "\033[J"
<- " "
<- "\033[C"
<- "\033[D"
<- "\033[J"
<- " "
<- "\033[C\033[C\033[C"
<- "\033[D\033[D\033[D"
<- "\033[J"
<- " "
<- "\033[C"
<- "\033[D"
<- "\033[J"
<- " "
<- "\033[C\033[C\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[D\033[D"
<- "\033[J"
<- " "
<- "\033[C"
<- ""
<- "d"
<- "b"
<- "x"
<- "e"
<- "n"
<- "v"
<- ""
<- " "
<- " "
<- " "
<- " "
<- " "
<- "^"
<- ""
<- "Unable to parse input as legal command or "
<- "C++"
<- " expression."
<- ""
<- "(ladebug) "
-> "set"
<- "set"
<- "\033[J"
<- " "
<- "\033[C"
<- "\033[D"
<- "\033[J"
<- " "
<- "\033[C"
<- "\033[D"
<- "\033[J"
<- " "
<- "\033[C\033[C\033[C"
<- ""
<- "$ascii = 1\n"
<- "$beep = 1\n"
<- "$catchexecs = 0\n"
<- "$catchforks = 0\n"
<- "$curevent = 0\n"
<- "$curfile = \"./cxxtest.C\"\n"
<- "$curline = 509\n"
<- "$curpc = 0x3ff8001ce58\n"
<- "$cursrcline = 524\n"
<- "$curthread = 3\n"
<- "$decints = 0\n"
<- "$editline = 1\n"
<- "$eventecho = 1\n"
<- "$hasmeta = 0\n"
<- "$hexints = 0\n"
<- "$historylines = 20\n"
<- "$indent = 1\n"
<- "$lang = \"C++\"\n"
<- "$lc_ctype = \"C\"\n"
<- "$listwindow = 20\n"
<- "$main = \"\\\"./cxxtest.C\\\"`main\"\n"
<- "$maxstrlen = 128\n"
<- "$octints = 0\n"
<- "$overloadmenu = 1\n"
<- "$page = 1\n"
<- "$pagewindow = 0\n"
<- "$pimode = 0\n"
<- "$prompt = \"(ladebug) \"\n"
<- "$repeatmode = 1\n"
<- "$stackargs = 1\n"
<- "$stepg0 = 0\n"
<- "$stoponattach = 0\n"
<- "$stopparentonfork = 0\n"
<- "$threadlevel = \"native\"\n"
<- "$usedynamictypes = 1\n"
<- "$verbose = 0\n"
<- "(ladebug) "
-> "help variable"
<- "\033[J"
<- " "
<- "\033[C"
<- "\033[D"
<- "\033[J"
<- " "
<- "\033[C"
<- "\033[D"
<- "\033[J"
<- " "
<- "\033[C\033[C\033[C"
<- "\033[D\033[D\033[D"
<- "\033[J"
<- " "
<- "\033[C"
<- "\033[D"
<- "\033[J"
<- " "
<- "\033[C\033[C\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[D\033[D"
<- "\033[J"
<- " "
<- "\033[C"
<- "\033[D"
<- "\033[J"
<- " "
<- "\033[C\033[C\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[D\033[D"
<- "\033[J"
<- " "
<- "\033[C"
<- "\033[D"
<- "\033[J"
<- " "
<- "\033[C\033[C\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[D\033[D"
<- "\033[J"
<- " "
<- "\033[C"
<- "\033[D"
<- "\033[J"
<- " "
<- "\033[C\033[C\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[D\033[D"
<- "\033[J"
<- " "
<- "\033[C"
<- "\033[D"
<- "\033[J"
<- " "
<- "\033[C\033[C\033[C\033[C\033[C"
<- ""
<- ""
<- "To look at the value of a variable, use the \'print\' command "
<- "For example, to look at the value of the object in \'t1\': "
<- " "
<- "(ladebug) print t1 "
<- "class Example_Class { "
<- "  publicDataMember = 0; "
<- "  protectedDataMember = 0; "
<- "  privateDataMember = 0; "
<- "  exampleClassNumber = 0; "
<- "} "
<- "(ladebug) "
<- " "
<- "To change the value of the variable, use the \'assign\' command: "
<- " "
<- "(ladebug) assign t1.publicDataMember = 23 "
<- "(ladebug) print t1 "
<- "class Example_Class { "
<- "  publicDataMember = 23; "
<- "  protectedDataMember = 0; "
<- "  privateDataMember = 0; "
<- "  exampleClassNumber = 0; "
<- "} "
<- "(ladebug) "
<- " "
<- "To find out more about the type of a variable, use the  "
<- "\'whatis\' command.  In this example, t1 is a C++ object of "
<- "the Example_Class class.  The \'whatis\' command shows the "
<- "data members and the member functions of the class: "
<- " "
<- "(ladebug) whatis t1 "
<- "class Example_Class  { "
<- "  unsigned long publicDataMember; "
<- "  unsigned long protectedDataMember; "
<- "  unsigned long privateDataMember; "
<- "  unsigned long exampleClassNumber; "
<- "  Example_Class(void); "
<- "  Example_Class(const Example_Class&); "
<- "  void publicFunction(void); "
<- "  void protectedFunction(void); "
<- "  void privateFunction(void); "
<- "  ~Example_Class(void); "
<- "} t1 "
<- "(ladebug) "
<- " "
<- "You get the same results if you ask \'whatis\' about the type "
<- "name, as in \'whatis Example_Class\'. "
<- " "
<- "If the variable is a pointer, you can use the appropriate "
<- "dereferencing operators to show you the value: "
<- " "
<- "(ladebug) whatis t3 "
<- "Example_Class* t3 "
<- "(ladebug) print t3 "
<- "0x140002800 "
<- "(ladebug) print *t3 "
<- "class Example_Class { "
<- "  publicDataMember = 25; "
<- "  protectedDataMember = 2; "
<- "  privateDataMember = 2; "
<- "  exampleClassNumber = 2; "
<- "} "
<- "(ladebug) print t3->publicDataMember "
<- "25 "
<- "(ladebug) "
<- " "
<- "You can use the same method to change the value of  "
<- "something referenced through a pointer: "
<- " "
<- "(ladebug) assign t3->publicDataMember = 27 "
<- "(ladebug) print t3->publicDataMember "
<- "27 "
<- "(ladebug) "
<- " "
<- "For more details, use \'help print\', \'help assign\', or  "
<- "\'help whatis\'. "
<- "(ladebug) "
#  Retrieving Ladebug Settings...done.
#  Retrieving Ladebug Settings...done.
-> "print type_test"
<- "\033[J "
<- "(function [0x120003660])"
<- "(ladebug) "
-> "help $variable"
<- "\033[J "
<- ""
<- "Ladebug defines a set of debugger variables that control\n"
<- "specific debugger operations.  These variables are:\n"
<- "\n"
<- "$ascii                  Print ASCII or all ISO Latin-1\n"
<- "$beep                   Beep on illegal command line editing\n"
<- "$catchexecs             Stop execution on program exec\n"
<- "$catchforks             Notify user on program fork\n"
<- "$curevent               Event number of current event\n"
<- "$curfile                Current source file \n"
<- "$curline                Current source line\n"
<- "$curpc                  Current point of program execution\n"
<- "$cursrcline             Last source line plus one\n"
<- "$curthread              Current thread ID\n"
<- "$decints                Display integers in decimal radix\n"
<- "$editline               Enable command line editing\n"
<- "$eventecho              Echo events with event numbers\n"
<- "$hasmeta                Interpret multi-byte characters \n"
<- "$hexints                Display integers in hex radix\n"
<- "$historylines           Number of commands to show for \'history\'\n"
<- "$indent                 Print structures with indentation\n"
<- "$lang                   Programming language of current routine\n"
<- "$lc_ctype               Current locale information\n"
<- "$listwindow             Number of lines to show for \'list\'\n"
<- "$main                   Name of first routine in program\n"
<- "$maxstrlen              Largest string to print fully\n"
<- "$octints                Display integers in octal radix\n"
<- "$overloadmenu           Prompt for choice of overloaded C++ name\n"
<- "$page                   Paginate debugger terminal output\n"
<- "$pagewindow             Number of lines per output page\n"
<- "$pimode                 Echo input to log file on \'playback input\'\n"
<- "$prompt                 Specify debugger prompt\n"
<- "$repeatmode             Repeat previous command on <return>\n"
<- "$stackargs              Show arguments in the call stack\n"
<- "$stepg0                 Step over routines with minimal symbols\n"
<- "$stoponattach           Stop the running process on \'attach\'\n"
<- "$stopparentonfork       Stop parent process execution on fork\n"
<- "$threadlevel            DECthreads or native threads\n"
<- "$usedynamictypes        Evaluate using C++ static or dynamic type\n"
<- "$verbose                Produce even more output\n"
<- "\n"
<- "See the Ladebug debugger manual for detailed explanations\n"
<- "of what these variables do and their default values.\n"
<- "\n"
<- "To look at the value of a debugger variable, use the \'print\'\n"
<- "command:\n"
<- "\n"
<- "(ladebug) print $lang\n"
<- "\"C++\"\n"
<- "(ladebug)\n"
<- "\n"
<- "To look at the values of all of the debugger variables,\n"
<- "use the \'set\' command without an argument:\n"
<- "\n"
<- "(ladebug) set\n"
<- "$ascii = 0\n"
<- "$beep = 1\n"
<- "   .\n"
<- "   .\n"
<- "   .\n"
<- "$usedynamictypes = 1\n"
<- "$verbose = 0\n"
<- "(ladebug)\n"
<- "\n"
<- "To change the value of a debugger variable, use the \'set\'\n"
<- "command:\n"
<- "\n"
<- "(ladebug) set $lang = \"C\"\n"
<- "(ladebug) print $lang\n"
<- "\"C\"\n"
<- "(ladebug)\n"
<- "\n"
<- "For more details, use \'help set\' or \'help print\'.\n"
<- "(ladebug) "
-> "quit"
<- "\033[J "
#  Running Ladebug (pid 2229, tty /dev/ttyp5)...Exit 0.
#  Saving history in "/gow/ems/emssr/.ddd/history"...
#  Saving history in "/gow/ems/emssr/.ddd/history"...done.
#  Thanks for using DDD 3.2!
