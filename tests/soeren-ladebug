From: "Rex, Sören" <SRex@PSI.de>
Subject: ddd-3.2 interfering ladebug doesn't list source code on DEC Unix 
	V4.0d
To: "'bug-ddd@gnu.org'" <bug-ddd@gnu.org>
Date: Wed, 9 Feb 2000 12:06:08 +0100 
Resent-From: bug-ddd@gnu.org

Hallo folks,

I compiled ddd-3.2 on DEC Unix V4.0d using the native cxx V6.2.
Unfortunately ddd --ladebug cxxtest (on the cxx -g compiled cxxtest.C)
doesn't show the source code. (ladebug cxxtest; list does.)
Maybe there is a problem in the communcation between ddd and ladebug.
BTW, Edit -> Ladebug Settings ... is empty.

Sören Rex
Software Engineer
PSI AG

[2. application/octet-stream; log]...

GNU DDD 3.2 (alphaev56-dec-osf4.0d)
Copyright (C) 1995-1999 Technische Universitaet Braunschweig, Germany.
Copyright (C) 1999-2000 Universitaet Passau, Germany.
Compiled with cxx
Requires X11R6, Xt11R6, Motif 1.2.4 (OSF/Motif Version 1.2.4)
Includes DDD core, Manual, App defaults, XPM 3.4.11, Athena Panner
Built 2000-02-09 by Soeren Rex <srex@psi.de>.
$  ./ddd --ladebug cxxtest
+  /bin/sh -c 'exec ladebug '\''cxxtest'\'''
#  Hello, world!
#  Starting Ladebug...
#  Running Ladebug (pid 24700, tty /dev/ttyp3)...
#  Current language: c/c++
#  Creating "/gow/ems/emssr/.ddd/"...
#  Creating "/gow/ems/emssr/.ddd/"...done.
#  Creating "/gow/ems/emssr/.ddd/sessions/"...
#  Creating "/gow/ems/emssr/.ddd/sessions/"...done.
<- "Welcome to the Ladebug Debugger Version 4.0-48"
<- "------------------ "
<- "object file name: cxxtest "
<- "Reading symbolic information ..."
<- "done"
<- "(ladebug) "
-> "sh stty -echo -onlcr"
<- "\033[J "
<- "(ladebug) "
-> "set $page = 1"
<- "\033[J "
<- "(ladebug) "
-> "frame"
<- "\033[J "
<- "frame"
<- "    ^"
<- "Unable to parse input as legal command or C++ expression."
<- "(ladebug) "
-> "func"
<- "\033[J "
<- "int main(int, char**) in ./cxxtest.C line No. 509:"
<- "    509     int i = 42;"
<- "(ladebug) "
-> "dbxenv run_io"
<- "\033[J "
<- "dbxenv run_io"
<- "            ^"
<- "Unable to parse input as legal command or C++ expression."
<- "(ladebug) "
-> "print -r 4711"
<- "\033[J "
<- "print -r 4711"
<- "            ^"
<- "Unable to parse input as legal command or C++ expression."
<- "(ladebug) "
-> "where -h"
<- "\033[J "
<- "The \"where\" command has failed because there is no running program."
<- "(ladebug) "
-> "display"
<- "\033[J "
<- "display"
<- "      ^"
<- "Unable to parse input as legal command or C++ expression."
<- "(ladebug) "
-> "clear"
<- "\033[J "
<- "clear"
<- "    ^"
<- "Unable to parse input as legal command or C++ expression."
<- "(ladebug) "
-> "help handler"
<- "\033[J "
<- "Information about \"handler\" isn\'t available"
<- ""
<- ""
<- ""
<- "Welcome to the Ladebug debugger help system. "
<- " "
<- "To find out about:  "
<- " "
<- "        - starting up a program in Ladebug "
<- "                enter \'help start\' "
<- " "
<- "        - stopping at a specific place in your program "
<- "                enter \'help breakpoint\' "
<- " "
<- "        - making the program execute "
<- "                enter \'help execution\' "
<- " "
<- "        - saving or cloning a snapshot of the current process "
<- "                enter \'help snapshot\' "
<- " "
<- "        - determining the type or value of a program variable "
<- "                enter \'help variable\' "
<- " "
<- "        - reading or writing a memory location "
<- "                enter \'help memory\' "
<- " "
<- "        - reading or writing a register "
<- "                enter \'help register\' "
<- " "
<- "        - showing the current call stack "
<- "                enter \'help stack\' "
<- " "
<- "        - displaying the source text of your program "
<- "                enter \'help listing\' "
<- " "
<- "        - listing all of the ladebug commands "
<- "                enter \'help ladebug\' or \'help command\' "
<- " "
<- "To find out about all of the Ladebug commands, use "
<- "\'help ladebug\' or \'help command\'.  To find out about  "
<- "a specific command, use help, followed by the command  "
<- "verb, such as \'help quit\'."
<- "(ladebug) "
-> "pwd"
<- "\033[J "
<- "pwd"
<- "  ^"
<- "Unable to parse input as legal command or C++ expression."
<- "(ladebug) "
-> "help setenv"
<- "\033[J "
<- ""
<- "        setenv [<env_variable> [<value>]] "
<- ""
<- "Sets the value of the specified environment variable. If no variable "
<- "is specified, the command displays the values of all environment "
<- "variables. If a variable is specified but no value is specified, then "
<- "the variable is set to NULL. "
<- ""
<- "This command is not for the current debuggee\'s environment, but for "
<- "the environment of any debuggees subsequently created with fork(2) or "
<- "with subsequent \'run\' or \'rerun\' commands. "
<- ""
<- "\'export\' and \'setenv\' are synonyms. "
<- ""
<- "See the Ladebug Debugger Manual for more information on commands that "
<- "manipulate the environment of subsequent debuggees. "
<- "(ladebug) "
-> "help edit"
<- "\033[J "
<- "Information about \"edit\" isn\'t available"
<- ""
<- ""
<- ""
<- "Welcome to the Ladebug debugger help system. "
<- " "
<- "To find out about:  "
<- " "
<- "        - starting up a program in Ladebug "
<- "                enter \'help start\' "
<- " "
<- "        - stopping at a specific place in your program "
<- "                enter \'help breakpoint\' "
<- " "
<- "        - making the program execute "
<- "                enter \'help execution\' "
<- " "
<- "        - saving or cloning a snapshot of the current process "
<- "                enter \'help snapshot\' "
<- " "
<- "        - determining the type or value of a program variable "
<- "                enter \'help variable\' "
<- " "
<- "        - reading or writing a memory location "
<- "                enter \'help memory\' "
<- " "
<- "        - reading or writing a register "
<- "                enter \'help register\' "
<- " "
<- "        - showing the current call stack "
<- "                enter \'help stack\' "
<- " "
<- "        - displaying the source text of your program "
<- "                enter \'help listing\' "
<- " "
<- "        - listing all of the ladebug commands "
<- "                enter \'help ladebug\' or \'help command\' "
<- " "
<- "To find out about all of the Ladebug commands, use "
<- "\'help ladebug\' or \'help command\'.  To find out about  "
<- "a specific command, use help, followed by the command  "
<- "verb, such as \'help quit\'."
<- "(ladebug) "
-> "help make"
<- "\033[J "
<- "Information about \"make\" isn\'t available"
<- ""
<- ""
<- ""
<- "Welcome to the Ladebug debugger help system. "
<- " "
<- "To find out about:  "
<- " "
<- "        - starting up a program in Ladebug "
<- "                enter \'help start\' "
<- " "
<- "        - stopping at a specific place in your program "
<- "                enter \'help breakpoint\' "
<- " "
<- "        - making the program execute "
<- "                enter \'help execution\' "
<- " "
<- "        - saving or cloning a snapshot of the current process "
<- "                enter \'help snapshot\' "
<- " "
<- "        - determining the type or value of a program variable "
<- "                enter \'help variable\' "
<- " "
<- "        - reading or writing a memory location "
<- "                enter \'help memory\' "
<- " "
<- "        - reading or writing a register "
<- "                enter \'help register\' "
<- " "
<- "        - showing the current call stack "
<- "                enter \'help stack\' "
<- " "
<- "        - displaying the source text of your program "
<- "                enter \'help listing\' "
<- " "
<- "        - listing all of the ladebug commands "
<- "                enter \'help ladebug\' or \'help command\' "
<- " "
<- "To find out about all of the Ladebug commands, use "
<- "\'help ladebug\' or \'help command\'.  To find out about  "
<- "a specific command, use help, followed by the command  "
<- "verb, such as \'help quit\'."
<- "(ladebug) "
-> "help regs"
<- "\033[J "
<- "Information about \"regs\" isn\'t available"
<- ""
<- ""
<- ""
<- "Welcome to the Ladebug debugger help system. "
<- " "
<- "To find out about:  "
<- " "
<- "        - starting up a program in Ladebug "
<- "                enter \'help start\' "
<- " "
<- "        - stopping at a specific place in your program "
<- "                enter \'help breakpoint\' "
<- " "
<- "        - making the program execute "
<- "                enter \'help execution\' "
<- " "
<- "        - saving or cloning a snapshot of the current process "
<- "                enter \'help snapshot\' "
<- " "
<- "        - determining the type or value of a program variable "
<- "                enter \'help variable\' "
<- " "
<- "        - reading or writing a memory location "
<- "                enter \'help memory\' "
<- " "
<- "        - reading or writing a register "
<- "                enter \'help register\' "
<- " "
<- "        - showing the current call stack "
<- "                enter \'help stack\' "
<- " "
<- "        - displaying the source text of your program "
<- "                enter \'help listing\' "
<- " "
<- "        - listing all of the ladebug commands "
<- "                enter \'help ladebug\' or \'help command\' "
<- " "
<- "To find out about all of the Ladebug commands, use "
<- "\'help ladebug\' or \'help command\'.  To find out about  "
<- "a specific command, use help, followed by the command  "
<- "verb, such as \'help quit\'."
<- "(ladebug) "
-> "print \"DDD\""
<- "\033[J "
<- "DDD"
<- "(ladebug) "
-> "help when"
<- "\033[J "
<- ""
<- "\twhen {<command>[;...]} "
<- "\twhen if <expression> {<command>[;...]} "
<- "\twhen at <line_number> [if <expression>] {<command>[;...]} "
<- "\twhen in function [if <expression>] {<command>[;...]} "
<- "\twhen [thread <thread_identifier_list>] "
<- "\t [at <line_number>] [if <expression>] {<command>[;...]} "
<- "\twhen [thread <thread_identifier_list>] "
<- "\t [in <function>] [if <expression>] {<command>[;...]} "
<- ""
<- "Use the \'when\' command to execute the specified command. "
<- "(The \'when\' command does not suspend program execution.) "
<- "The debugger command must be enclosed in braces. Separate multiple "
<- "commands with semicolons. "
<- ""
<- "To execute a command when an expression evaluates true, use the second form. "
<- "To execute commands when a line or function is encountered, use the third "
<- "or fourth form. "
<- ""
<- "If you specify an expression, the command is executed only if the "
<- "expression evaluates true when the line or function is encountered. "
<- ""
<- "Use the \'when thread\' command to set tracepoints in specific threads. "
<- "If you list one or more thread identifiers, the debugger sets a tracepoint "
<- "only in those threads you specify.  If you omit the thread identifier "
<- "specification, the ebugger sets a tracepoint in all the threads of the "
<- "application. "
<- "(ladebug) "
-> "delete 4711 4711"
<- "\033[J "
<- "delete 4711 4711"
<- "               ^"
<- "Unable to parse input as legal command or C++ expression."
<- "(ladebug) "
-> "help run"
<- "\033[J "
<- ""
<- "        run [<program arguments>] [<io redirection>] "
<- "        rerun [<program arguments>] [<io redirection>] "
<- ""
<- "Use the \'run\' and \'rerun\' commands to start program execution. "
<- "Enter program flags, options, and input and output redirections "
<- "as arguments. If the \'rerun\' command is specified without "
<- "arguments, the arguments entered with the previous \'run\' "
<- "command are used.  If the last modification time and/or "
<- "size of the binary file or any of the shared objects used "
<- "by the binary file has changed since the last \'run\' command "
<- "was issued,  Ladebug automatically rereads the symbol "
<- "table information.  If this happens, the old breakpoint "
<- "settings may no longer be valid after the new symbol table "
<- "information is read. "
<- "(ladebug) "
-> "help givenfile"
<- "\033[J "
<- "Information about \"givenfile\" isn\'t available"
<- ""
<- ""
<- ""
<- "Welcome to the Ladebug debugger help system. "
<- " "
<- "To find out about:  "
<- " "
<- "        - starting up a program in Ladebug "
<- "                enter \'help start\' "
<- " "
<- "        - stopping at a specific place in your program "
<- "                enter \'help breakpoint\' "
<- " "
<- "        - making the program execute "
<- "                enter \'help execution\' "
<- " "
<- "        - saving or cloning a snapshot of the current process "
<- "                enter \'help snapshot\' "
<- " "
<- "        - determining the type or value of a program variable "
<- "                enter \'help variable\' "
<- " "
<- "        - reading or writing a memory location "
<- "                enter \'help memory\' "
<- " "
<- "        - reading or writing a register "
<- "                enter \'help register\' "
<- " "
<- "        - showing the current call stack "
<- "                enter \'help stack\' "
<- " "
<- "        - displaying the source text of your program "
<- "                enter \'help listing\' "
<- " "
<- "        - listing all of the ladebug commands "
<- "                enter \'help ladebug\' or \'help command\' "
<- " "
<- "To find out about all of the Ladebug commands, use "
<- "\'help ladebug\' or \'help command\'.  To find out about  "
<- "a specific command, use help, followed by the command  "
<- "verb, such as \'help quit\'."
<- "(ladebug) "
-> "help cont"
<- "\033[J "
<- ""
<- "        cont [<signal>] [to <line_number>] "
<- "        cont [in <function>] "
<- ""
<- "Use the \'cont\' command without a parameter value to resume program "
<- "execution until a breakpoint, a signal, an error, or the end of "
<- "the program is encountered.  Specify a signal parameter value to send "
<- "an operating system signal to the program continuing execution. "
<- "Specify a to line_number parameter value to halt program execution "
<- "when that line number is reached. "
<- ""
<- "When you use the \'cont\' commmand, Ladebug resumes execution of the "
<- "entire process. "
<- ""
<- "The signal parameter value can be either a signal number or a "
<- "string name (for example, SIGSEGV).  The default is 0, which "
<- "allows the program to continue execution without specifying a "
<- "signal.  If you specify a signal parameter value, the program "
<- "continues execution with that signal. "
<- ""
<- "The \'to line_number\' parameter value is used to resume execution and "
<- "then halt when the specified source line is reached. "
<- ""
<- "The form of the optional line_number argument must be one of the "
<- "following: "
<- "\t- line_number, a positive numeric, which indicates the "
<- "           line number of the current source file where execution "
<- "           is to be halted "
<- "        - \"filename\":line_number, which explicitly identifies both "
<- " \t  the source file and the line number where execution "
<- "          is to be halted. "
<- ""
<- "If the optional function name is provided, execution will be halted "
<- "when that function is reached.  This form of the \'cont\' command does "
<- "not support signals.  If the function name is overloaded, the user is "
<- "prompted with a choice of overloaded function names or \'none of the above\'. "
<- "Depending on user choice, program execution continues until the "
<- "specified function is reached or warns the user that no breakpoint is set."
<- "If the \'none of the above\' option is specified, program execution returns "
<- "to the \'ladebug\' prompt."
<- "(ladebug) "
-> "help examine"
<- "\033[J "
<- "Information about \"examine\" isn\'t available"
<- ""
<- ""
<- ""
<- "Welcome to the Ladebug debugger help system. "
<- " "
<- "To find out about:  "
<- " "
<- "        - starting up a program in Ladebug "
<- "                enter \'help start\' "
<- " "
<- "        - stopping at a specific place in your program "
<- "                enter \'help breakpoint\' "
<- " "
<- "        - making the program execute "
<- "                enter \'help execution\' "
<- " "
<- "        - saving or cloning a snapshot of the current process "
<- "                enter \'help snapshot\' "
<- " "
<- "        - determining the type or value of a program variable "
<- "                enter \'help variable\' "
<- " "
<- "        - reading or writing a memory location "
<- "                enter \'help memory\' "
<- " "
<- "        - reading or writing a register "
<- "                enter \'help register\' "
<- " "
<- "        - showing the current call stack "
<- "                enter \'help stack\' "
<- " "
<- "        - displaying the source text of your program "
<- "                enter \'help listing\' "
<- " "
<- "        - listing all of the ladebug commands "
<- "                enter \'help ladebug\' or \'help command\' "
<- " "
<- "To find out about all of the Ladebug commands, use "
<- "\'help ladebug\' or \'help command\'.  To find out about  "
<- "a specific command, use help, followed by the command  "
<- "verb, such as \'help quit\'."
<- "(ladebug) "
-> "help rerun"
<- "\033[J "
<- ""
<- "        run [<program arguments>] [<io redirection>] "
<- "        rerun [<program arguments>] [<io redirection>] "
<- ""
<- "Use the \'run\' and \'rerun\' commands to start program execution. "
<- "Enter program flags, options, and input and output redirections "
<- "as arguments. If the \'rerun\' command is specified without "
<- "arguments, the arguments entered with the previous \'run\' "
<- "command are used.  If the last modification time and/or "
<- "size of the binary file or any of the shared objects used "
<- "by the binary file has changed since the last \'run\' command "
<- "was issued,  Ladebug automatically rereads the symbol "
<- "table information.  If this happens, the old breakpoint "
<- "settings may no longer be valid after the new symbol table "
<- "information is read. "
<- "(ladebug) "
-> "language"
<- "\033[J "
<- "language"
<- "       ^"
<- "Unable to parse input as legal command or C++ expression."
<- "(ladebug) "
-> "sh pwd"
<- "\033[J "
<- "/gowd/ems/emssr/ddd/ddd-3.2/ddd"
<- "(ladebug) "
-> "file"
<- "\033[J "
<- "./cxxtest.C"
<- "(ladebug) "
-> "list"
<- "\033[J "
<- "    510     tree_test();"
<- "    511     i++;"
<- "    512     list_test(i);"
<- "    513     i++;"
<- "    514     array_test();"
<- "    515     i++;"
<- "    516     string_test();"
<- "    517     i++;"
<- "    518     plot_test();"
<- "    519     i++;"
<- "    520     type_test();"
<- "    521     --i;"
<- "    522     cin_cout_test();"
<- "    523     return 0;"
<- "    524 }"
<- "(ladebug) "
-> "status"
<- "\033[J "
<- "(ladebug) "
-> "debug "
<- "\033[J "
<- "debug "
<- "     ^"
<- "Unable to parse input as legal command or C++ expression."
<- "(ladebug) "
-> "# reset"
<- "\033[J "
<- "(ladebug) "
-> "file"
<- "\033[J "
<- "./cxxtest.C"
<- "(ladebug) "
-> "list"
<- "\033[J "
<- "(File ./cxxtest.C has only 524 lines; the current line number is 525)"
<- "(ladebug) "
-> "status"
<- "\033[J "
<- "(ladebug) "
-> "setenv TERM dumb"
<- "\033[J "
<- "(ladebug) "
-> "debug "
<- "\033[J "
<- "debug "
<- "     ^"
<- "Unable to parse input as legal command or C++ expression."
<- "(ladebug) "
#  Creating options in "/gow/ems/emssr/.ddd/init"...
#  Creating options in "/gow/ems/emssr/.ddd/init"...done.
-> "help detach"
<- "\033[J "
<- ""
<- "        detach [process_id_list] "
<- ""
<- "Use the \'detach\' command to detach from a running process you specify "
<- "from the process ID list.  Specifying a process ID and detaching from "
<- "the process disables your ability to debug the process.  If you do not "
<- "specify a process ID from the list, Ladebug detaches from the "
<- "current process. "
<- "(ladebug) "
#  Starting Ladebug...done.
#  Welcome to DDD 3.2 "Man Ray" (alphaev56-dec-osf4.0d)
-> "help run"
<- "\033[J "
<- ""
<- "        run [<program arguments>] [<io redirection>] "
<- "        rerun [<program arguments>] [<io redirection>] "
<- ""
<- "Use the \'run\' and \'rerun\' commands to start program execution. "
<- "Enter program flags, options, and input and output redirections "
<- "as arguments. If the \'rerun\' command is specified without "
<- "arguments, the arguments entered with the previous \'run\' "
<- "command are used.  If the last modification time and/or "
<- "size of the binary file or any of the shared objects used "
<- "by the binary file has changed since the last \'run\' command "
<- "was issued,  Ladebug automatically rereads the symbol "
<- "table information.  If this happens, the old breakpoint "
<- "settings may no longer be valid after the new symbol table "
<- "information is read. "
<- "(ladebug) "
-> "help step"
<- "\033[J "
<- ""
<- "        step [<expression>]"
<- ""
<- "Use the \'next\' and \'step\' commands to execute a line of source "
<- "code.  When the next line to be executed contains a function call, "
<- "the \'next\' command executes the function being called and returns "
<- "to the line immediately after the function call. The \'step\' "
<- "command steps into the function and executes only the first line "
<- "of the function. "
<- ""
<- "For multithreaded applications, use these commands to step the "
<- "current thread while putting all other threads on hold. "
<- ""
<- "If the optional <expression> argument is supplied, Ladebug will "
<- "evaluate the number of times to execute the command.  The expression "
<- "can be any expression that is valid within the current context. "
<- "(ladebug) "
-> "help stepi"
<- "\033[J "
<- ""
<- "        stepi [<expression>]"
<- ""
<- "Use the \'stepi\' command and the \'nexti\' command to execute a "
<- "machine instruction. When the instruction contains a function call, "
<- "the \'stepi\' command steps into the function being called, and the "
<- "\'nexti\' command executes the function being called. "
<- ""
<- "For multithreaded applications, use these commands to step the "
<- "current thread while putting all other threads on hold. "
<- ""
<- "If the optional <expression> argument is supplied, Ladebug will "
<- "evaluate the number of times to execute the command.  The expression "
<- "can be any expression that is valid within the current context. "
<- "(ladebug) "
-> "help next"
<- "\033[J "
<- ""
<- "        next [<expression>] "
<- ""
<- "Use the \'next\' and \'step\' commands to execute a line of source "
<- "code.  When the next line to be executed contains a function call, "
<- "the \'next\' command executes the function being called and returns "
<- "to the line immediately after the function call.  The \'step\' "
<- "command executes only the first line of the function. "
<- ""
<- "For multithreaded applications, use these commands to step the "
<- "current thread while putting all other threads on hold. "
<- ""
<- "If the optional <expression> argument is supplied, Ladebug will "
<- "evaluate the number of times to execute the command.  The expression "
<- "can be any expression that is valid within the current context. "
<- "(ladebug) "
-> "help nexti"
<- "\033[J "
<- ""
<- "        nexti [<expression>] "
<- ""
<- "Use the \'stepi\' command and the \'nexti\' command to execute a "
<- "machine instruction.  When the instruction contains a function "
<- "call, the \'stepi\' command steps into the function being called, "
<- "and the \'nexti\' command executes the function being called. "
<- ""
<- "For multithreaded applications, use these commands to step the "
<- "current thread while putting all other threads on hold. "
<- ""
<- "If the optional <expression> argument is supplied, Ladebug will "
<- "evaluate the number of times to execute the command.  The expression "
<- "can be any expression that is valid within the current context. "
<- "(ladebug) "
-> "help until"
<- "\033[J "
<- "Information about \"until\" isn\'t available"
<- ""
<- ""
<- ""
<- "Welcome to the Ladebug debugger help system. "
<- " "
<- "To find out about:  "
<- " "
<- "        - starting up a program in Ladebug "
<- "                enter \'help start\' "
<- " "
<- "        - stopping at a specific place in your program "
<- "                enter \'help breakpoint\' "
<- " "
<- "        - making the program execute "
<- "                enter \'help execution\' "
<- " "
<- "        - saving or cloning a snapshot of the current process "
<- "                enter \'help snapshot\' "
<- " "
<- "        - determining the type or value of a program variable "
<- "                enter \'help variable\' "
<- " "
<- "        - reading or writing a memory location "
<- "                enter \'help memory\' "
<- " "
<- "        - reading or writing a register "
<- "                enter \'help register\' "
<- " "
<- "        - showing the current call stack "
<- "                enter \'help stack\' "
<- " "
<- "        - displaying the source text of your program "
<- "                enter \'help listing\' "
<- " "
<- "        - listing all of the ladebug commands "
<- "                enter \'help ladebug\' or \'help command\' "
<- " "
<- "To find out about all of the Ladebug commands, use "
<- "\'help ladebug\' or \'help command\'.  To find out about  "
<- "a specific command, use help, followed by the command  "
<- "verb, such as \'help quit\'."
<- "(ladebug) "
-> "help cont"
<- "\033[J "
<- ""
<- "        cont [<signal>] [to <line_number>] "
<- "        cont [in <function>] "
<- ""
<- "Use the \'cont\' command without a parameter value to resume program "
<- "execution until a breakpoint, a signal, an error, or the end of "
<- "the program is encountered.  Specify a signal parameter value to send "
<- "an operating system signal to the program continuing execution. "
<- "Specify a to line_number parameter value to halt program execution "
<- "when that line number is reached. "
<- ""
<- "When you use the \'cont\' commmand, Ladebug resumes execution of the "
<- "entire process. "
<- ""
<- "The signal parameter value can be either a signal number or a "
<- "string name (for example, SIGSEGV).  The default is 0, which "
<- "allows the program to continue execution without specifying a "
<- "signal.  If you specify a signal parameter value, the program "
<- "continues execution with that signal. "
<- ""
<- "The \'to line_number\' parameter value is used to resume execution and "
<- "then halt when the specified source line is reached. "
<- ""
<- "The form of the optional line_number argument must be one of the "
<- "following: "
<- "\t- line_number, a positive numeric, which indicates the "
<- "           line number of the current source file where execution "
<- "           is to be halted "
<- "        - \"filename\":line_number, which explicitly identifies both "
<- " \t  the source file and the line number where execution "
<- "          is to be halted. "
<- ""
<- "If the optional function name is provided, execution will be halted "
<- "when that function is reached.  This form of the \'cont\' command does "
<- "not support signals.  If the function name is overloaded, the user is "
<- "prompted with a choice of overloaded function names or \'none of the above\'. "
<- "Depending on user choice, program execution continues until the "
<- "specified function is reached or warns the user that no breakpoint is set."
<- "If the \'none of the above\' option is specified, program execution returns "
<- "to the \'ladebug\' prompt."
<- "(ladebug) "
-> "help signal"
<- "\033[J "
<- "Information about \"signal\" isn\'t available"
<- ""
<- ""
<- ""
<- "Welcome to the Ladebug debugger help system. "
<- " "
<- "To find out about:  "
<- " "
<- "        - starting up a program in Ladebug "
<- "                enter \'help start\' "
<- " "
<- "        - stopping at a specific place in your program "
<- "                enter \'help breakpoint\' "
<- " "
<- "        - making the program execute "
<- "                enter \'help execution\' "
<- " "
<- "        - saving or cloning a snapshot of the current process "
<- "                enter \'help snapshot\' "
<- " "
<- "        - determining the type or value of a program variable "
<- "                enter \'help variable\' "
<- " "
<- "        - reading or writing a memory location "
<- "                enter \'help memory\' "
<- " "
<- "        - reading or writing a register "
<- "                enter \'help register\' "
<- " "
<- "        - showing the current call stack "
<- "                enter \'help stack\' "
<- " "
<- "        - displaying the source text of your program "
<- "                enter \'help listing\' "
<- " "
<- "        - listing all of the ladebug commands "
<- "                enter \'help ladebug\' or \'help command\' "
<- " "
<- "To find out about all of the Ladebug commands, use "
<- "\'help ladebug\' or \'help command\'.  To find out about  "
<- "a specific command, use help, followed by the command  "
<- "verb, such as \'help quit\'."
<- "(ladebug) "
-> "help kill"
<- "\033[J "
<- "\033[C"
<- "\033[D"
<- "\033[J "
<- "\033[C"
<- "\033[D"
<- "\033[J"
<- " "
<- "\033[C\033[C\033[C"
<- "\033[D\033[D\033[D"
<- "\033[J"
<- " "
<- "\033[C"
<- "\033[D"
<- "\033[J"
<- " "
<- "\033[C\033[C\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[D\033[D"
<- "\033[J"
<- " "
<- "\033[C"
<- "\033[D"
<- "\033[J"
<- " "
<- "\033[C\033[C\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[D\033[D"
<- "\033[J"
<- " "
<- "\033[C"
<- "\033[D"
<- "\033[J"
<- " "
<- "\033[C\033[C\033[C\033[C\033[C"
<- ""
<- ""
<- "        kill "
<- ""
<- "Use the \'kill\' command to terminate the program process leaving "
<- "the debugger running.  When a process terminates, any breakpoints "
<- "and traces previously set are retained.  You can later rerun the "
<- "program. "
<- "(ladebug) "
-> "help up"
<- "\033[J"
<- " "
<- "\033[C"
<- "\033[D"
<- "\033[J"
<- " "
<- "\033[C"
<- "\033[D"
<- "\033[J"
<- " "
<- "\033[C\033[C\033[C"
<- "\033[D\033[D\033[D"
<- "\033[J"
<- " "
<- "\033[C"
<- "\033[D"
<- "\033[J"
<- " "
<- "\033[C\033[C\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[D\033[D"
<- "\033[J"
<- " "
<- "\033[C"
<- "\033[D"
<- "\033[J"
<- " "
<- "\033[C\033[C\033[C\033[C\033[C"
<- ""
<- ""
<- "        up [<integer>] "
<- ""
<- "Use the \'up\' command or the \'down\' command without an argument to change the "
<- "function scope to the function located one level up or down the stack.  "
<- ""
<- "Enter a number argument to change the function scope to the function "
<- "up or down the specified number of levels. If the number of levels "
<- "exceeds the number of active functions on the stack, the function "
<- "scope moves up or down as many levels as possible and the debugger "
<- "issues a warning message. "
<- ""
<- "When the function scope changes, the debugger displays the source line "
<- "corresponding to the last point of execution in that function. "
<- "(ladebug) "
-> "help down"
<- "\033[J"
<- " "
<- "\033[C"
<- "\033[D"
<- "\033[J"
<- " "
<- "\033[C"
<- "\033[D"
<- "\033[J"
<- " "
<- "\033[C\033[C\033[C"
<- "\033[D\033[D\033[D"
<- "\033[J"
<- " "
<- "\033[C"
<- "\033[D"
<- "\033[J"
<- " "
<- "\033[C\033[C\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[D\033[D"
<- "\033[J"
<- " "
<- "\033[C"
<- "\033[D"
<- "\033[J"
<- " "
<- "\033[C\033[C\033[C\033[C\033[C"
<- "\033[D\033[D\033[D\033[D\033[D"
<- "\033[J"
<- " "
<- "\033[C"
<- "\033[D"
<- "\033[J"
<- " "
<- "\033[C\033[C\033[C\033[C\033[C"
<- ""
<- ""
<- "        down [<integer>] "
<- ""
<- "Use the \'up\' command or the \'down\' command without an argument to "
<- "change the function scope to the function located one level up or "
<- "down the stack. "
<- ""
<- "Enter a number argument to change the function scope to the "
<- "function up or down the specified number of levels.  If the number "
<- "of levels exceeds the number of active functions on the stack, "
<- "the function scope moves up or down as many levels as possible "
<- "and the debugger issues a warning message. "
<- ""
<- "When the function scope changes, the debugger displays the source "
<- "line corresponding to the last point of execution in the function."
<- "(ladebug) "
-> "quit"
<- "\033[J "
#  Running Ladebug (pid 24700, tty /dev/ttyp3)...Exit 0.
#  Saving history in "/gow/ems/emssr/.ddd/history"...
#  Saving history in "/gow/ems/emssr/.ddd/history"...done.
#  Thanks for using DDD 3.2!
